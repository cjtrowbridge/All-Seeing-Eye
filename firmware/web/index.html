<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> ‚ú®üëÅ‚ú® All-Seeing Eye</title>
    <style>
        :root {
            --bg-color: #121212;
            --card-color: #1e1e1e;
            --text-color: #e0e0e0;
            --accent-color: #bb86fc;
            --danger-color: #cf6679;
            --success-color: #03dac6;
            --border-color: #333;
        }
        * { box-sizing: border-box; }
        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            display: grid;
            grid-template-rows: auto 1fr auto auto; /* Header, Main, Controls, Footer */
            height: 100vh;
            overflow: hidden;
        }
        header {
            background-color: var(--panel-color);
            padding: 0 20px;
            height: 50px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
        }
        h1 { margin: 0; font-size: 1.1rem; display: flex; align-items: center; gap: 10px; font-weight: 500; letter-spacing: 1px; }
        .status-badge {
            background: #333;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            color: #aaa;
            text-transform: uppercase;
        }
        .status-badge.active { color: var(--bg-color); background: var(--success-color); font-weight: bold; }
        
        main {
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        #log-panel {
            flex: 1;
            padding: 10px 20px;
            overflow-y: auto;
            font-family: 'Consolas', monospace;
            font-size: 0.85rem;
            color: #ccc;
            border-bottom: 1px solid var(--border-color);
            background: #141414;
        }
        .log-entry { margin-bottom: 4px; border-bottom: 1px solid #222; padding-bottom: 2px; }
        .log-time { color: #666; margin-right: 8px; }

        /* Tabs */
        .tabs {
            display: flex;
            background: #1a1a1a;
            border-bottom: 1px solid var(--border-color);
        }
        .tab-btn {
            padding: 10px 20px;
            cursor: pointer;
            border: none;
            background: transparent;
            color: #888;
            border-right: 1px solid #222;
            font-size: 0.9rem;
            text-transform: uppercase;
        }
        .tab-btn:hover { background: #222; color: #fff; }
        .tab-btn.active {
            border-bottom: 2px solid #bb86fc;
            color: #bb86fc;
        }
        
        /* Sub-tabs for Logs */
        .sub-tabs {
            display: flex;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
        }
        .sub-tab-btn {
            flex: 1;
            background: none;
            border: none;
            color: #888;
            padding: 10px;
            cursor: pointer;
            font-size: 0.8rem;
            text-transform: uppercase;
        }
        .sub-tab-btn.active {
            color: #ffb74d; /* Orange for logs */
            background: #252525;
        }
        .log-container {
            display: none;
            flex: 1;
            overflow: hidden;
            position: relative;
        }
        .log-container.active {
            display: flex;
            flex-direction: column;
        }
        .log-box {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            font-family: 'Consolas', monospace;
            font-size: 0.8rem;
            line-height: 1.4;
        }

        .tab-content {
            display: none;
            flex: 1;
            overflow-y: auto;
            position: relative;
            padding: 20px;
        }
        .tab-content.active { display: block; }
        
        #tab-logs { padding: 0; display: flex; flex-direction: column; }
        #log-list { flex: 1; padding: 10px; overflow-y: auto; font-family: 'Consolas', monospace; font-size: 0.85rem; color: #ccc; }

        /* Persistent Viz Panel */
        #viz-panel {
            height: 200px; /* Fixed height for persistent visualization */
            background: #000;
            position: relative;
            border-top: 1px solid var(--border-color);
            border-bottom: 1px solid var(--border-color);
        }
        
        #spectrum-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Network Map */
        #network-map-container {
            height: 300px;
            background: #0a0a0a;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            margin: 20px 0;
            position: relative;
            overflow: hidden;
        }
        #network-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Controls moved to Task View */
        .controls-container {
            display: flex;
            gap: 15px;
            align-items: center;
            background: #222;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #333;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        label { font-size: 0.7rem; color: #888; text-transform: uppercase; }
        input, select {
            background: #111;
            border: 1px solid #444;
            color: white;
            padding: 6px 10px;
            border-radius: 3px;
            font-size: 0.9rem;
        }
        button { 
            background: var(--accent-color); 
            color: black; 
            font-weight: bold; 
            cursor: pointer; 
            border: none;
            padding: 8px 16px;
            border-radius: 3px;
            text-transform: uppercase;
            font-size: 0.8rem;
            margin-top: auto; 
        }
        button:hover { opacity: 0.9; }

        footer {
            background: #0e0e0e;
            padding: 5px 20px;
            font-size: 0.75rem;
            color: #666;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .stat-item { margin-right: 15px; }
        .stat-val { color: #888; margin-left: 5px; }
        
        /* Tree View for Clusters */
        .tree-node { margin-left: 20px; padding: 5px 0; }
        .cluster-root { font-weight: bold; color: var(--success-color); margin-bottom: 5px; }
        .device-node { color: #aaa; display: flex; gap: 10px; padding: 5px; background: #1a1a1a; margin-bottom: 2px; border-radius: 4px; }
        .device-node:hover { background: #333; cursor: pointer; }

        /* Desktop Layout (3 Columns) */
        @media (min-width: 1024px) {
            .tabs { display: none !important; }
            
            main {
                display: grid !important;
                grid-template-columns: 1fr 1fr 1fr;
                grid-template-rows: 1fr 200px;
                gap: 1px;
                background: #333; /* Separator lines */
            }

            .tab-content {
                display: flex !important;
                flex-direction: column;
                background: var(--bg-color);
                border: none;
                overflow: hidden;
                grid-row: 1;
            }

            /* Assign Columns */
            #tab-clusters { grid-column: 1; }
            #tab-task { grid-column: 2; border-left: 1px solid #333; border-right: 1px solid #333; }
            #tab-logs { grid-column: 3; }

            /* Viz Panel spans bottom */
            #viz-panel {
                grid-row: 2;
                grid-column: 1 / -1;
                border-top: 1px solid #333;
                background: #000;
                height: auto; /* Fill grid row */
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>
            <span>‚ú®üëÅÔ∏è‚ú®</span> All-Seeing Eye 
            <span id="connection-status" class="status-badge">DISCONNECTED</span>
            <span id="cluster-status" style="font-size: 0.8rem; color: #888; font-weight: normal; margin-left: 10px;">
                ‚ú® Current Cluster: Default ‚ú® Working On: Idle ‚ú®
            </span>
        </h1>
    </header>

    <main>
        <!-- Tabs Header -->
        <div class="tabs">
            <button class="tab-btn active" onclick="switchTab('clusters')">Clusters</button>
            <button class="tab-btn" onclick="switchTab('task')">Task View</button>
            <button class="tab-btn" onclick="switchTab('logs')">Logs</button>
        </div>

        <!-- Tab Content: Clusters -->
        <div id="tab-clusters" class="tab-content active">
            <div id="cluster-tree">
                <!-- Dynamic Content Loaded by JS -->
                <div style="text-align:center; padding:20px; color:#666;">Loading Cluster Matrix...</div>
            </div>
            <div style="margin-top:20px; color:#666; font-size:0.8rem; text-align:center;">
                Discovery: mDNS (Active) | Viral Intercept (Active) | Subnet Scan (Auto)
            </div>

            <!-- Network Visualization -->
            <div id="network-map-container">
                <canvas id="network-canvas"></canvas>
                <div style="position:absolute; bottom:5px; right:10px; font-size:0.7rem; color:#444;">Live Topology</div>
            </div>

            <!-- Queue Status -->
            <div id="queue-status-container" style="margin-top:20px; padding:15px; background:var(--card-color); border:1px solid var(--border-color); border-radius:5px;">
                <h4 style="margin-top:0; border-bottom:1px solid #333; padding-bottom:5px;">Current Queue Status</h4>
                <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px; font-size:0.9rem;">
                    <div>Current Task: <span id="q-task" style="color:var(--accent-color)">-</span></div>
                    <div>Plugin: <span id="q-plugin" style="color:#aaa">-</span></div>
                    <div>Duration: <span id="q-duration">-</span></div>
                    <div>Elapsed: <span id="q-elapsed">-</span></div>
                    <div>Queue Depth: <span id="q-depth">-</span></div>
                </div>
            </div>
        </div>

        <!-- Tab Content: Task View -->
        <div id="tab-task" class="tab-content">
            <h3 style="margin-top:0">Current Task</h3>
            <div class="controls-container">
                <div class="control-group">
                    <label>Mode</label>
                    <select id="mode-select">
                        <option value="IDLE">Idle</option>
                        <option value="SCANNER">Scanner</option>
                        <option value="MONITOR">Single Freq</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Frequency (MHz)</label>
                    <input type="number" id="freq-input" value="915.0" step="0.1" style="width: 100px;">
                </div>
                <button id="apply-btn">APPLY CONFIG</button>
            </div>
            
            <div style="margin-top:20px; padding:15px; background:#1a1a1a; border-radius:4px;">
                <strong>Cluster Strategy:</strong> Independent<br>
                <small style="color:#888;">This node is currently operating independently. Join a managed cluster to synchronize tasks.</small>
            </div>
        </div>

        <!-- Tab Content: Logs -->
        <div id="tab-logs" class="tab-content" style="display:none; flex-direction:column;">
            <h3 style="margin-top:0">Logs</h3>
            <div class="sub-tabs">
                <button class="sub-tab-btn active" onclick="switchLogMode('tail')" title="View current runtime logs (last 50 entries)">Tail</button>
                <button class="sub-tab-btn" onclick="switchLogMode('head')" title="View boot sequence logs (first 50 entries)">Head</button>
            </div>
            
            <div id="log-container-tail" class="log-container active">
                <div id="log-list" class="log-box">
                    <div style="text-align:center; color:#444; margin-top:20px;">Waiting for live logs...</div>
                </div>
            </div>

            <div id="log-container-head" class="log-container">
                <div id="log-list-head" class="log-box">
                    <div style="text-align:center; color:#444; margin-top:20px;">Loading startup logs...</div>
                </div>
            </div>
        </div>
        
        <!-- Persistent Viz -->
        <div id="viz-panel">
            <canvas id="spectrum-canvas"></canvas>
        </div>
    </main>


    <footer>
        <span class="stat-item">RAM: <span id="stat-ram" class="stat-val">--</span></span>
        <span class="stat-item">UPTIME: <span id="stat-uptime" class="stat-val">--</span></span>
        <span class="stat-item">PLUGIN: <span id="stat-plugin" class="stat-val">--</span></span>
        <span style="flex:1"></span>
        <span id="stat-version" style="opacity:0.5">v1.0</span>
    </footer>

    <script>
        // Tab Switcher
        function switchTab(tabId) {
            // Hide all
            document.querySelectorAll('.tab-content').forEach(el => {
                el.style.display = 'none';
                el.classList.remove('active');
            });
            document.querySelectorAll('.tab-btn').forEach(el => el.classList.remove('active'));

            // Show One
            const content = document.getElementById('tab-' + tabId);
            content.style.display = (tabId === 'logs') ? 'flex' : 'block'; // Logs needs flex for scroll
            content.classList.add('active');
            
            // Highlight Btn (Find by onclick attr matching... crude but works for simple app)
            // Or better, stick to index? Let's just Loop.
            const btns = document.querySelectorAll('.tab-btn');
            if(tabId === 'clusters') btns[0].classList.add('active');
            if(tabId === 'task') btns[1].classList.add('active');
            if(tabId === 'logs') btns[2].classList.add('active');
        }

        // Log Mode Switcher
        function switchLogMode(mode) {
            // Buttons
            document.querySelectorAll('.sub-tab-btn').forEach(b => b.classList.remove('active'));
            // Containers
            document.querySelectorAll('.log-container').forEach(c => c.classList.remove('active'));

            if (mode === 'tail') {
                document.querySelectorAll('.sub-tab-btn')[0].classList.add('active');
                document.getElementById('log-container-tail').classList.add('active');
            } else {
                document.querySelectorAll('.sub-tab-btn')[1].classList.add('active');
                document.getElementById('log-container-head').classList.add('active');
                fetchHeadLogs(); // Load on demand (idempotent)
            }
        }

        let headLogsLoaded = false;
        async function fetchHeadLogs() {
            if (headLogsLoaded) return; // Only fetch once
            
            try {
                const res = await fetch('/api/logs/head');
                const logs = await res.json();
                const container = document.getElementById('log-list-head');
                
                if (Array.isArray(logs) && logs.length > 0) {
                    container.innerHTML = logs.map(l => `<div class="log-entry">${l}</div>`).join('');
                } else {
                    container.innerHTML = '<div style="text-align:center; color:#666; padding:20px;">No startup logs recorded.</div>';
                }
                headLogsLoaded = true;
            } catch(e) {
                console.error("Failed to fetch head logs", e);
                document.getElementById('log-list-head').innerHTML = '<div style="color:var(--danger-color); padding:20px;">Error loading logs.</div>';
            }
        }

        // State
        const IP = window.location.hostname === "localhost" ? "allseeingeye.local" : window.location.hostname;
        // Local Device store
        let myDevice = { hostname: "Loading...", ip: IP, status: "Unknown", cluster: "Default", online: true, isSelf: true };
        let currentBuildId = null; 
        
        const canvas = document.getElementById('spectrum-canvas');
        const ctx = canvas.getContext('2d');
        const logBox = document.getElementById('log-list');
        
        // Network Viz Globals
        const netCanvas = document.getElementById('network-canvas');
        const netCtx = netCanvas.getContext('2d');
        let netNodes = [];
        let netLinks = [];

        // Resize Canvas
        function resize() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            netCanvas.width = netCanvas.offsetWidth;
            netCanvas.height = netCanvas.offsetHeight;
        }
        window.addEventListener('resize', resize);
        // Delay initial resize to ensure layout is done
        setTimeout(resize, 100);

        // Polling Status
        async function fetchStatus() {
            try {
                const res = await fetch('/api/status');
                const data = await res.json();
                
                // RAM Percentage
                let ramText = Math.round(data.heap_free/1024) + "k";
                if(data.heap_size) {
                    const pct = Math.round(((data.heap_size - data.heap_free) / data.heap_size) * 100);
                    ramText = pct + "% (" + ramText + " free)";
                }

                document.getElementById('stat-ram').innerText = ramText;
                document.getElementById('stat-uptime').innerText = Math.round(data.uptime/1000) + "s";
                document.getElementById('stat-plugin').innerText = data.plugin || "None";
                
                // Update Local Device State
                if(data.hostname) myDevice.hostname = data.hostname;
                myDevice.status = data.status || "Unknown";
                myDevice.cluster = data.clusterName || "Default"; // Backend provides clusterName
                myDevice.task = data.task || "Unknown Task";
                myDevice.lastProbe = Date.now(); // Self is always fresh

                document.getElementById('connection-status').innerText = "ONLINE";
                document.getElementById('connection-status').classList.add('active');

                // Mock Cluster Status update (backend not ready yet)
                // In future: data.clusterName and data.clusterTask
                const taskDesc = (data.plugin === "Scanner") ? "Broadband Sweep (Custom) ‚ú®" 
                               : (data.plugin === "RadioTest") ? "Hardware Verification ‚ú®"
                               : (data.plugin === "SystemIdle") ? "Searching for cluster friends üëÄ"
                               : "Idle ‚ú®";
                
                document.getElementById('cluster-status').innerText = 
                    `Current Cluster: ${data.clusterName || "Default"} ‚ú® Working On: ${taskDesc}`;

                // Auto-Reload on Firmware Update
                if (data.build_id) {
                    if (currentBuildId === null) {
                        currentBuildId = data.build_id;
                        console.log("Registered Build ID:", currentBuildId);
                    } else if (currentBuildId !== data.build_id) {
                        console.log("New Firmware Detected! Reloading...");
                        window.location.reload();
                    }
                }
                
                // --- PROCESS QUEUE STATUS ---
                if (data.queue && data.queue.current) {
                    const q = data.queue.current;
                    document.getElementById('q-task').innerText = q.task || "Idle";
                    document.getElementById('q-plugin').innerText = q.plugin || "SystemIdle";
                    document.getElementById('q-duration').innerText = q.duration > 0 ? q.duration + "ms" : "Indefinite";
                    document.getElementById('q-elapsed').innerText = q.elapsed + "ms";
                    document.getElementById('q-depth').innerText = data.queue.depth || 0;
                }

                // --- PROCESS AGGREGATED DATA ---
                
                // 1. Logs
                if (data.logs && Array.isArray(data.logs)) {
                     const slice = data.logs; // Backend already limits to 50
                     logBox.innerHTML = slice.map(l => `<div class="log-entry">${l}</div>`).join('');
                     logBox.scrollTop = logBox.scrollHeight;
                }

                // 2. Peers
                if (data.peers && Array.isArray(data.peers)) {
                    renderPeerList(data.peers);
                    
                    // Trigger Crawl for Visualization (Throttled?)
                    if(!isCrawling) {
                        crawlNetwork(data.peers);
                    }
                }

            } catch(e) {
                document.getElementById('connection-status').innerText = "OFFLINE";
                document.getElementById('connection-status').classList.remove('active');
            }
        }
        setInterval(fetchStatus, 2000);
        fetchStatus();

        // Fetch Peers & Crawl
        let isCrawling = false;
        
        // Removed dedicated fetchPeers() polling loop
        // Removed dedicated fetchLogs() polling loop

        function renderPeerList(peers) {
             const container = document.getElementById('cluster-tree');
                
            // Merge Self into Peer List for unified rendering
            const allNodes = [ myDevice, ...peers ];
            
            // Group by Cluster
            const clusters = {};
            allNodes.forEach(p => {
                // Normalize cluster name
                let c = p.cluster;
                if (!c || c === "") c = "Default";
                
                if(!clusters[c]) clusters[c] = [];
                clusters[c].push(p);
            });
            
            // Build HTML
            let html = "";
            const sortedKeys = Object.keys(clusters).sort();
            
            for (const cName of sortedKeys) {
                const cPeers = clusters[cName];
                const isMyCluster = (cName === myDevice.cluster);
                const headerColor = isMyCluster ? "var(--success-color)" : "#bb86fc";
                const suffix = isMyCluster ? " (Local)" : "";
                
                html += `<div class="cluster-root" style="margin-top:15px; color:${headerColor};">Cluster: ${cName}${suffix}</div>`;
                
                html += cPeers.map(p => {
                        const isMe = p.isSelf;
                        const link = `http://${(p.hostname || p.ip).toLowerCase()}.local`; // Try mDNS
                        const alternateLink = `http://${p.ip}`; 
                        
                        // Prefer Hostname (mDNS) over IP
                        const finalLink = (p.hostname && p.hostname !== "Unknown") ? link : alternateLink;

                        const statusColor = (p.status && (p.status.startsWith("Ready") || p.status.startsWith("Working"))) ? 'var(--success-color)' : 
                                        (p.status && p.status.startsWith("Error")) ? 'var(--danger-color)' : '#666';
                        
                        const taskStr = p.task || "Unknown Task";
                        
                        return `
                    <div class="tree-node">
                        <div class="device-node" onclick="window.location.href='${finalLink}'" title="Task: ${taskStr} | Click to open dashboard" style="${isMe ? 'border:1px solid #333;' : ''}">
                            <span style="color:${isMe ? 'white':'#aaa'}; font-weight:bold;">${p.hostname}</span>
                            <span style="margin-left:10px; font-size: 0.8rem; color:#888;">${taskStr}</span>
                            <span style="margin-left:5px; font-size: 0.8rem; color:${p.online ? statusColor : '#666'}">[${p.online ? (p.status || 'Active') : 'Offline'}]</span>
                            <div style="flex:1"></div>
                            <span style="color:#444; font-size:0.8rem;">${isMe ? "(This Device)" : p.ip}</span>
                        </div>
                    </div>
                `}).join('');
            }
            container.innerHTML = html;
        }

        async function crawlNetwork(localPeers) {
            isCrawling = true;
            const nodeMap = new Map();
            const links = [];

            // Add Self
            nodeMap.set(myDevice.hostname, myDevice);

            // Add Local Peers (Degree 1) and Links from Me -> Them
            localPeers.forEach(p => {
                nodeMap.set(p.hostname, p);
                links.push({ source: myDevice.hostname, target: p.hostname });
            });

            // Fetch Degree 2 (Peers of Peers)
            // This allows us to see connections between my peers
            const promises = localPeers.map(async (p) => {
                if (!p.ip) return;
                try {
                    const controller = new AbortController();
                    const id = setTimeout(() => controller.abort(), 2000); // 2s Timeout
                    
                    const res = await fetch(`http://${p.ip}/api/peers`, { signal: controller.signal });
                    clearTimeout(id);
                    
                    if (res.ok) {
                        const remotePeers = await res.json();
                        remotePeers.forEach(rp => {
                            // Link p -> rp
                            links.push({ source: p.hostname, target: rp.hostname });

                            // If we haven't seen this node, it's a Degree 2 node
                            if (!nodeMap.has(rp.hostname)) {
                                rp.degree = 2; 
                                nodeMap.set(rp.hostname, rp);
                            }
                        });
                    }
                } catch (e) {
                    // Peer might be offline or CORS blocked (if old firmware)
                    // console.warn("Crawl failed for", p.hostname); 
                }
            });

            await Promise.all(promises);
            
            updateNetworkGraph(Array.from(nodeMap.values()), links);
            isCrawling = false;
        }

        // --- Force Directed Graph Logic ---
        
        function updateNetworkGraph(nodes, externalLinks) {
            // nodes is [ {hostname, cluster, status...}, ... ]
            
            // 1. Map current netNodes to a map for lookup (preserve positions)
            const existing = new Map(netNodes.map(n => [n.id, n]));
            
            // 2. Build new node list
            netNodes = nodes.map(n => {
                const id = n.hostname;
                const old = existing.get(id);
                // Random position start if new
                const x = old ? old.x : (netCanvas.width/2 + (Math.random()-0.5)*50);
                const y = old ? old.y : (netCanvas.height/2 + (Math.random()-0.5)*50);
                
                return {
                    id: id,
                    x: x,
                    y: y,
                    vx: old ? old.vx : 0,
                    vy: old ? old.vy : 0,
                    data: n
                };
            });

            // 3. Build Links
            if (externalLinks) {
                // Use crawled links
                netLinks = externalLinks;
            } else {
                // Fallback: Star Topology
                netLinks = [];
                const centerId = myDevice.hostname;
                netNodes.forEach(n => {
                    if (n.id !== centerId) {
                        netLinks.push({ source: centerId, target: n.id });
                    }
                });
            }
        }

        function runForceSimulation() {
            if(!netNodes.length) {
                requestAnimationFrame(runForceSimulation);
                return;
            }

            const width = netCanvas.width;
            const height = netCanvas.height;
            const k = 100; // ideal distance
            
            // 0. Center Forces (Gravity)
            const cx = width / 2;
            const cy = height / 2;

            // Physics Step
            netNodes.forEach(n => {
                // Repulsion (Coulomb)
                netNodes.forEach(other => {
                    if (n !== other) {
                        const dx = n.x - other.x;
                        const dy = n.y - other.y;
                        const distSq = dx*dx + dy*dy;
                        const dist = Math.sqrt(distSq) || 1;
                        const force = 2000 / distSq; // Repulsion strength
                        n.vx += (dx / dist) * force;
                        n.vy += (dy / dist) * force;
                    }
                });

                // Center Gravity (weak)
                n.vx += (cx - n.x) * 0.005;
                n.vy += (cy - n.y) * 0.005;

                // Cluster Gravity (Group similar clusters)
                // TODO: Find center of mass of cluster? 
                // Simple version: Nodes in same cluster attract slightly
                /*
                netNodes.forEach(other => {
                    if (n !== other && n.data.cluster === other.data.cluster) {
                        const dx = other.x - n.x;
                        const dy = other.y - n.y;
                         n.vx += dx * 0.001;
                         n.vy += dy * 0.001;
                    }
                });
                */
            });

            // Link Attraction (Spring)
            netLinks.forEach(l => {
                // Find node objects
                const s = netNodes.find(n => n.id === l.source);
                const t = netNodes.find(n => n.id === l.target);
                if (s && t) {
                    const dx = t.x - s.x;
                    const dy = t.y - s.y;
                    const dist = Math.sqrt(dx*dx + dy*dy) || 1;
                    const force = (dist - k) * 0.05; // Spring constant
                    
                    const fx = (dx / dist) * force;
                    const fy = (dy / dist) * force;
                    
                    s.vx += fx;
                    s.vy += fy;
                    t.vx -= fx;
                    t.vy -= fy;
                }
            });

            // Integration & Bounds
            netNodes.forEach(n => {
                n.vx *= 0.8; // Friction
                n.vy *= 0.8;
                
                // Max speed clamp
                const speed = Math.sqrt(n.vx*n.vx + n.vy*n.vy);
                if(speed > 10) {
                    n.vx = (n.vx/speed)*10;
                    n.vy = (n.vy/speed)*10;
                }

                n.x += n.vx;
                n.y += n.vy;

                // Wall bounce
                if(n.x < 20) { n.x = 20; n.vx *= -0.5; }
                if(n.x > width-20) { n.x = width-20; n.vx *= -0.5; }
                if(n.y < 20) { n.y = 20; n.vy *= -0.5; }
                if(n.y > height-20) { n.y = height-20; n.vy *= -0.5; }
            });

            // Draw
            netCtx.clearRect(0, 0, width, height);

            // Draw Links
            netCtx.strokeStyle = '#333';
            netCtx.lineWidth = 1;
            netCtx.beginPath();
            netLinks.forEach(l => {
                const s = netNodes.find(n => n.id === l.source);
                const t = netNodes.find(n => n.id === l.target);
                if (s && t) {
                    netCtx.moveTo(s.x, s.y);
                    netCtx.lineTo(t.x, t.y);
                }
            });
            netCtx.stroke();

            // Draw Nodes
            netNodes.forEach(n => {
                netCtx.beginPath();
                netCtx.arc(n.x, n.y, 8, 0, 2 * Math.PI);
                
                // Color by Status/Self
                if (n.data.isSelf) netCtx.fillStyle = '#03dac6'; // Cyan
                else if (n.data.online) netCtx.fillStyle = '#bb86fc'; // Purple
                else netCtx.fillStyle = '#444'; // Gray
                
                netCtx.fill();
                netCtx.strokeStyle = '#000';
                netCtx.lineWidth = 2;
                netCtx.stroke();

                // Labels
                netCtx.fillStyle = '#fff';
                netCtx.font = '10px Consolas';
                netCtx.fillText(n.id, n.x + 10, n.y + 3);
            });

            requestAnimationFrame(runForceSimulation);
        }
        
        // Start Sim
        runForceSimulation();

        // Canvas Interaction (Click to Visit)
        netCanvas.addEventListener('click', (e) => {
            const rect = netCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Check collision with nodes
            for (const n of netNodes) {
                const dx = mouseX - n.x;
                const dy = mouseY - n.y;
                // Hit radius 12 (drawn radius is 8)
                if (dx*dx + dy*dy < 144) { 
                    const p = n.data;
                    const link = `http://${(p.hostname || p.ip).toLowerCase()}.local`;
                    const alternateLink = `http://${p.ip}`; 
                    const finalLink = (p.hostname && p.hostname !== "Unknown") ? link : alternateLink;
                    window.location.href = finalLink;
                    break;
                }
            }
        });

        // Mouse Move for Cursor
        netCanvas.addEventListener('mousemove', (e) => {
            const rect = netCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            let hover = false;
            for (const n of netNodes) {
                const dx = mouseX - n.x;
                const dy = mouseY - n.y;
                if (dx*dx + dy*dy < 144) {
                    hover = true;
                    break;
                }
            }
            netCanvas.style.cursor = hover ? 'pointer' : 'default';
        });

        // Dummy Viz
        function drawPattern() {
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.fillRect(0,0,canvas.width, canvas.height);
            
            ctx.fillStyle = '#03dac6';
            const h = canvas.height;
            const w = canvas.width;
            
            // Draw grid
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for(let x=0; x<w; x+=50) { ctx.moveTo(x,0); ctx.lineTo(x,h); }
            ctx.stroke();

            for(let i=0; i<w; i+=10) {
                const noise = Math.random() * (h * 0.8);
                ctx.fillRect(i, h - noise, 8, noise);
            }
            requestAnimationFrame(drawPattern);
        }
        drawPattern();

        // Init Tab
        switchTab('clusters');
    </script>
