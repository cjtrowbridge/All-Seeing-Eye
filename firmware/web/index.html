<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> ‚ú®üëÅ‚ú® All-Seeing Eye</title>
    <style>
        :root {
            --bg-color: #121212;
            --card-color: #1e1e1e;
            --text-color: #e0e0e0;
            --accent-color: #bb86fc;
            --danger-color: #cf6679;
            --success-color: #03dac6;
            --border-color: #333;
        }
        * { box-sizing: border-box; }
        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            display: grid;
            grid-template-rows: auto 1fr auto auto; /* Header, Main, Controls, Footer */
            height: 100vh;
            overflow: hidden;
        }
        header {
            background-color: var(--panel-color);
            padding: 0 20px;
            height: 50px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
        }
        h1 { margin: 0; font-size: 1.1rem; display: flex; align-items: center; gap: 10px; font-weight: 500; letter-spacing: 1px; }
        .status-badge {
            background: #333;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            color: #aaa;
            text-transform: uppercase;
        }
        .status-badge.active { color: var(--bg-color); background: var(--success-color); font-weight: bold; }
        
        main {
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        #log-panel {
            flex: 1;
            padding: 10px 20px;
            overflow-y: auto;
            font-family: 'Consolas', monospace;
            font-size: 0.85rem;
            color: #ccc;
            border-bottom: 1px solid var(--border-color);
            background: #141414;
        }
        .log-entry { margin-bottom: 4px; border-bottom: 1px solid #222; padding-bottom: 2px; }
        .log-time { color: #666; margin-right: 8px; }

        /* Tabs */
        .tabs {
            display: flex;
            background: #1a1a1a;
            border-bottom: 1px solid var(--border-color);
        }
        .tab-btn {
            padding: 10px 20px;
            cursor: pointer;
            border: none;
            background: transparent;
            color: #888;
            border-right: 1px solid #222;
            font-size: 0.9rem;
            text-transform: uppercase;
        }
        .tab-btn:hover { background: #222; color: #fff; }
        .tab-btn.active {
            border-bottom: 2px solid #bb86fc;
            color: #bb86fc;
        }
        
        /* Sub-tabs for Logs */
        .sub-tabs {
            display: flex;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
        }
        .sub-tab-btn {
            flex: 1;
            background: none;
            border: none;
            color: #888;
            padding: 10px;
            cursor: pointer;
            font-size: 0.8rem;
            text-transform: uppercase;
        }
        .sub-tab-btn.active {
            color: #ffb74d; /* Orange for logs */
            background: #252525;
        }
        .led-circle {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background-color: #000;
            border: 1px solid #555;
            cursor: pointer;
            box-shadow: 0 0 2px rgba(0,0,0,0.5);
            transition: all 0.3s ease;
        }
        .led-circle:hover { transform: scale(1.2); }
        
        .log-container {
            display: none;
            flex: 1;
            overflow: hidden;
            position: relative;
        }
        .log-container.active {
            display: flex;
            flex-direction: column;
        }

        /* Generic Sub-Tab Content Container */
        .sub-tab-content {
            display: none;
            flex-direction: column;
            padding: 15px;
            overflow-y: auto;
            flex: 1;
        }
        .sub-tab-content.active {
            display: flex;
        }

        .log-box {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            font-family: 'Consolas', monospace;
            font-size: 0.8rem;
            line-height: 1.4;
        }

        .tab-content {
            display: none;
            flex: 1;
            overflow-y: auto;
            position: relative;
            padding: 20px;
        }
        .tab-content.active { display: block; }
        
        #tab-logs { display: flex; flex-direction: column; }
        #log-list { flex: 1; padding: 10px; overflow-y: auto; font-family: 'Consolas', monospace; font-size: 0.85rem; color: #ccc; }

        /* Persistent Viz Panel */
        #viz-panel {
            height: 200px; /* Fixed height for persistent visualization */
            background: #000;
            position: relative;
            border-top: 1px solid var(--border-color);
            border-bottom: 1px solid var(--border-color);
        }
        
        #spectrum-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Network Map */
        #network-map-container {
            height: 300px;
            background: #0a0a0a;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            margin: 20px 0;
            position: relative;
            overflow: hidden;
        }
        #network-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Controls moved to Task View */
        .controls-container {
            display: flex;
            gap: 15px;
            align-items: center;
            background: #222;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #333;
        }

        .controls-container-vertical {
            display: flex;
            flex-direction: column;
            gap: 15px;
            background: #222;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #333;
        }

        .task-sub-content {
            padding-top: 20px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        label { font-size: 0.7rem; color: #888; text-transform: uppercase; }
        input, select {
            background: #111;
            border: 1px solid #444;
            color: white;
            padding: 6px 10px;
            border-radius: 3px;
            font-size: 0.9rem;
        }
        button { 
            background: var(--accent-color); 
            color: black; 
            font-weight: bold; 
            cursor: pointer; 
            border: none;
            padding: 8px 16px;
            border-radius: 3px;
            text-transform: uppercase;
            font-size: 0.8rem;
            margin-top: auto; 
        }
        button:hover { opacity: 0.9; }

        footer {
            background: #0e0e0e;
            padding: 5px 20px;
            font-size: 0.75rem;
            color: #666;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .stat-item { margin-right: 15px; }
        .stat-val { color: #888; margin-left: 5px; }
        
        /* Tree View for Clusters */
        .tree-node { margin-left: 20px; padding: 5px 0; }
        .cluster-root { font-weight: bold; color: var(--success-color); margin-bottom: 5px; }
        .device-node { color: #aaa; display: flex; gap: 10px; padding: 5px; background: #1a1a1a; margin-bottom: 2px; border-radius: 4px; }
        .device-node:hover { background: #333; cursor: pointer; }

        .device-node .edit-icon { opacity: 0; cursor: pointer; margin-left:10px; font-size: 1.2em; color: #888; }
        .device-node:hover .edit-icon { opacity: 1; }
        .device-node .edit-icon:hover { color: var(--accent-color); }
        .rename-input { background: #333; color: white; border: 1px solid #555; padding: 2px 5px; font-size: 0.9em;  }

        /* Desktop Layout (3 Columns) */
        @media (min-width: 1024px) {
            .tabs { display: none !important; }
            
            main {
                display: grid !important;
                grid-template-columns: 1fr 1fr 1fr;
                grid-template-rows: 1fr 200px;
            }
            /* Assign Columns */
            #tab-clusters { grid-column: 1; }
            #tab-task { grid-column: 2; border-left: 1px solid #333; border-right: 1px solid #333; padding: 0 !important; }
            #tab-logs { grid-column: 3; }
            .tab-content {
                display: flex !important;
                flex-direction: column;
                background: var(--bg-color);
                border: none;
                overflow: hidden;
                grid-row: 1;
            }

            /* Viz Panel spans bottom */
            #viz-panel {
                grid-row: 2;
                grid-column: 1 / -1;
                border-top: 1px solid #333;
                background: #000;
                height: auto; /* Fill grid row */
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>
            <span>‚ú®üëÅÔ∏è‚ú®</span> All-Seeing Eye 
            <span id="connection-status" class="status-badge">DISCONNECTED</span>
            <span id="cluster-status" style="font-size: 0.8rem; color: #888; font-weight: normal; margin-left: 10px;">
                ‚ú® Current Cluster: Default ‚ú® Working On: Idle ‚ú®
            </span>
            <span style="font-size: 0.8rem; color: #888; margin-left: 10px;">‚ú®</span>
            <div id="led-indicator" class="led-circle" title="LED Status: Click to configure"></div>
        </h1>
    </header>

    <main>
        <!-- Tabs Header -->
        <div class="tabs">
            <button id="btn-tab-clusters" class="tab-btn active">Clusters</button>
            <button id="btn-tab-task" class="tab-btn">Task View</button>
            <button id="btn-tab-logs" class="tab-btn">Logs</button>
        </div>

        <!-- Tab Content: Clusters -->
        <div id="tab-clusters" class="tab-content active">
            <h3 style="margin-top:0">Cluster Overview</h3>
            <div id="cluster-tree">
                <!-- Dynamic Content Loaded by JS -->
                <div style="text-align:center; padding:20px; color:#666;">Loading Cluster Matrix...</div>
            </div>
            <div style="margin-top:20px; color:#666; font-size:0.8rem; text-align:center;">
                Discovery: mDNS (Active) | Viral Intercept (Active) | Subnet Scan (Auto)
            </div>

            <!-- Network Visualization -->
            <div id="network-map-container">
                <canvas id="network-canvas"></canvas>
                <div style="position:absolute; bottom:5px; right:10px; font-size:0.7rem; color:#444;">Live Topology</div>
            </div>

            <!-- Queue Status -->
            <h4 style="margin-top:10px; margin-bottom: 10px; color: #888; text-transform: uppercase; font-size: 0.8rem; border-bottom: 1px solid #333;">Active Queue</h4>
            <div class="controls-container" style="flex-direction:column; align-items:stretch; margin-bottom: 20px; font-size: 0.8rem;">
                <div style="display:flex; justify-content:space-between;"><span>Task:</span> <span id="q-task" style="color:white">--</span></div>
                <div style="display:flex; justify-content:space-between;"><span>Plugin:</span> <span id="q-plugin" style="color:white">--</span></div>
                <div style="display:flex; justify-content:space-between;"><span>Elapsed:</span> <span id="q-elapsed" style="color:white">--</span></div>
                <div style="display:flex; justify-content:space-between;"><span>Duration:</span> <span id="q-duration" style="color:white">--</span></div>
                <div style="display:flex; justify-content:space-between;"><span>Depth:</span> <span id="q-depth" style="color:white">--</span></div>
            </div>
        </div>

        <!-- Tab Content: Task View -->
        <div id="tab-task" class="tab-content" style="padding:0; display:none; flex-direction:column;">
            <div class="sub-tabs">
                <button id="btn-task-device" class="sub-tab-btn active">Device</button>
                <button id="btn-task-task" class="sub-tab-btn">Task</button>
            </div>

            <!-- SubTab: Device -->
            <div id="subtab-device" class="sub-tab-content">
                <h3 style="margin-top:0">Device Identity</h3>
                <div class="controls-container" style="margin-bottom:20px; flex-direction:column; align-items:stretch;">
                    <div class="control-group">
                        <label>Description (Friendly Name)</label>
                        <input type="text" id="cfg-desc" placeholder="e.g. Kitchen Node">
                    </div>
                    <div class="control-group">
                        <label>Hostname</label>
                        <input type="text" id="cfg-hostname" placeholder="ase-xxxx">
                    </div>
                    <div class="control-group">
                        <label>Cluster</label>
                        <input type="text" id="cfg-cluster" placeholder="Default">
                    </div>
                    <div class="control-group">
                        <label>Timezone (IANA)</label>
                        <input type="text" id="cfg-timezone" placeholder="America/Los_Angeles">
                    </div>
                    <button id="btn-update-identity" style="margin-top:10px; width:100%;">UPDATE IDENTITY</button>
                </div>
                
                <div style="margin-top:auto; padding:15px; background:#1a1a1a; border-radius:4px;">
                     <strong>Cluster Strategy:</strong> Independent<br>
                     <small style="color:#888;">This node is currently operating independently.</small>
                </div>
            </div>

            <!-- SubTab: Task -->
            <div id="subtab-task" class="sub-tab-content active">
                <h3 style="margin-top:0">New Task</h3>
                <div class="controls-container" style="margin-bottom:20px; flex-direction:column; align-items:stretch;">
                    <div class="control-group">
                        <label>Plugin Template</label>
                        <select id="task-plugin-select" disabled style="opacity: 0.5;">
                            <option>Scanner (Default)</option>
                        </select>
                    </div>
                </div>

                <h4 style="margin-top:10px; margin-bottom: 10px; color: #888; text-transform: uppercase; font-size: 0.8rem; border-bottom: 1px solid #333;">Manual Scan</h4>
                <div class="controls-container" style="flex-direction:column; align-items:stretch;">
                    <div class="control-group">
                        <label>Start Frequency (MHz)</label>
                        <input type="number" id="scan-start-freq" value="902.0" step="0.1">
                    </div>
                    <div class="control-group">
                        <label>Stop Frequency (MHz)</label>
                        <input type="number" id="scan-stop-freq" value="928.0" step="0.1">
                    </div>
                    <div class="control-group">
                        <label>Resolution Bandwidth (kHz)</label>
                        <input type="number" id="scan-rbw" value="500" step="1">
                    </div>
                    <div class="control-group" style="flex-direction:row; align-items:center; gap:10px; margin: 10px 0;">
                        <input type="checkbox" id="scan-continuous" style="width:auto; margin:0;">
                        <label style="margin:0;">Continuous Scan</label>
                    </div>
                    <div style="display:flex; gap:10px;">
                        <button id="btn-scan-start" style="flex:1;">START</button>
                        <button id="btn-scan-stop" style="flex:1; background:var(--danger-color); color:white;">STOP</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Tab Content: Logs -->
        <div id="tab-logs" class="tab-content" style="display:none; flex-direction:column;">
            <h3 style="margin-top:0">Logs</h3>
            <div class="sub-tabs">
                <button id="btn-log-tail" class="sub-tab-btn active" title="View current runtime logs (last 50 entries)">Tail</button>
                <button id="btn-log-head" class="sub-tab-btn" title="View boot sequence logs (first 50 entries)">Head</button>
            </div>
            
            <div id="log-container-tail" class="log-container active">
                <div id="log-list" class="log-box">
                    <div style="text-align:center; color:#444; margin-top:20px;">Waiting for live logs...</div>
                </div>
            </div>

            <div id="log-container-head" class="log-container">
                <div id="log-list-head" class="log-box">
                    <div style="text-align:center; color:#444; margin-top:20px;">Loading startup logs...</div>
                </div>
            </div>
        </div>
        
        <!-- Persistent Viz -->
        <div id="viz-panel">
            <canvas id="spectrum-canvas"></canvas>
        </div>
    </main>


    <footer>
        <span class="stat-item">RAM: <span id="stat-ram" class="stat-val">--</span></span>
        <span class="stat-item">UPTIME: <span id="stat-uptime" class="stat-val">--</span></span>
        <span class="stat-item">PLUGIN: <span id="stat-plugin" class="stat-val">--</span></span>
        <span style="flex:1"></span>
        <span id="stat-version" style="opacity:0.5">v1.0</span>
    </footer>

    <script>
        // Tab Switcher
        function switchTab(tabId) {
            // Hide all
            document.querySelectorAll('.tab-content').forEach(el => {
                el.style.display = 'none';
                el.classList.remove('active');
            });
            document.querySelectorAll('.tab-btn').forEach(el => el.classList.remove('active'));

            // Show One
            const content = document.getElementById('tab-' + tabId);
            content.style.display = (tabId === 'logs' || tabId === 'task') ? 'flex' : 'block'; 
            content.classList.add('active');
            
            // Highlight Btn (Find by onclick attr matching... crude but works for simple app)
            // Or better, stick to index? Let's just Loop.
            const btns = document.querySelectorAll('.tab-btn');
            if(tabId === 'clusters') btns[0].classList.add('active');
            if(tabId === 'task') btns[1].classList.add('active');
            if(tabId === 'logs') btns[2].classList.add('active');
        }

        // Log Mode Switcher
        function switchLogMode(mode) {
            const parent = document.getElementById('tab-logs');
            // Buttons in this tab only
            parent.querySelectorAll('.sub-tab-btn').forEach(b => b.classList.remove('active'));
            // Containers
            document.querySelectorAll('.log-container').forEach(c => c.classList.remove('active'));

            if (mode === 'tail') {
                parent.querySelectorAll('.sub-tab-btn')[0].classList.add('active');
                document.getElementById('log-container-tail').classList.add('active');
            } else {
                parent.querySelectorAll('.sub-tab-btn')[1].classList.add('active');
                document.getElementById('log-container-head').classList.add('active');
                fetchHeadLogs(); // Load on demand (idempotent)
            }
        }

        let headLogsLoaded = false;
        async function fetchHeadLogs() {
            if (headLogsLoaded) return; // Only fetch once
            
            try {
                const res = await fetch('/api/logs/head');
                const logs = await res.json();
                const container = document.getElementById('log-list-head');
                
                 // Safe Clear
                 while(container.firstChild) container.removeChild(container.firstChild);

                if (Array.isArray(logs) && logs.length > 0) {
                     logs.forEach(l => {
                        const div = document.createElement('div');
                        div.className = 'log-entry';
                        div.textContent = l;
                        container.appendChild(div);
                     });
                } else {
                    const msg = document.createElement('div');
                    msg.style.textAlign = 'center';
                    msg.style.color = '#666';
                    msg.style.padding = '20px';
                    msg.textContent = 'No startup logs recorded.';
                    container.appendChild(msg);
                }
                headLogsLoaded = true;
            } catch(e) {
                console.error("Failed to fetch head logs", e);
                const c = document.getElementById('log-list-head');
                if(c) {
                    c.textContent = "Error loading logs.";
                    c.style.color = "var(--danger-color)";
                    c.style.padding = "20px";
                }
            }
        }

        // Task Sub-Tab Switcher
        function switchTaskSubTab(mode) {
             const parent = document.getElementById('tab-task');
             // Buttons
             parent.querySelectorAll('.sub-tab-btn').forEach(b => b.classList.remove('active'));
             // Containers
             parent.querySelectorAll('.sub-tab-content').forEach(c => c.classList.remove('active'));

             if (mode === 'device') {
                 parent.querySelectorAll('.sub-tab-btn')[0].classList.add('active');
                 document.getElementById('subtab-device').classList.add('active');
             } else {
                 parent.querySelectorAll('.sub-tab-btn')[1].classList.add('active');
                 document.getElementById('subtab-task').classList.add('active');
             }
        }

        // State
        const IP = window.location.hostname === "localhost" ? "allseeingeye.local" : window.location.hostname;
        // Local Device store
        let myDevice = { hostname: "Loading...", description: "", ip: IP, status: "Unknown", cluster: "Default", timezone: "America/Los_Angeles", online: true, isSelf: true };
        let currentBuildId = null; 
        
        // LED Config
        async function configureLed() {
            // Get current color from status (or just prompt empty)
            const input = prompt("Enter RGB values (e.g. 255,0,128)\nEnter 0,0,0 to disable LED.", "0,0,0");
            if (!input) return;

            const parts = input.split(',').map(s => parseInt(s.trim()));
            if(parts.length !== 3 || parts.some(isNaN)) {
                alert("Invalid format. Use r,g,b");
                return;
            }
            
            const [r,g,b] = parts;
            
            try {
                if(r===0 && g===0 && b===0) {
                    await fetch('/api/led/off', { method: 'POST' });
                } else {
                    // Update Color first (silent if off)
                    await fetch(`/api/led?r=${r}&g=${g}&b=${b}`);
                    // Then Turn On
                    await fetch('/api/led/on', { method: 'POST' });
                }
                // Refresh Page to show update
                window.location.reload();
            } catch(e) {
                alert("LED Control Failed: " + e);
            }
        }

        // Functions
        async function applyIdentity() {
            const desc = document.getElementById('cfg-desc').value;
            const host = document.getElementById('cfg-hostname').value;
            const clust = document.getElementById('cfg-cluster').value;
            const tz = document.getElementById('cfg-timezone').value;
            
            if(!host) return alert("Hostname is required");
            
            try {
                const res = await fetch('/api/config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        description: desc,
                        hostname: host,
                        cluster: clust,
                        timezone: tz
                    })
                });
                const j = await res.json();
                if(j.status === 'success') {
                    alert("Identity Updated. Rebooting may be required for Hostname changes.");
                                        alert("Identity Updated. Reboot may be required for Hostname/Timezone changes.");
                    fetchStatus(); // Refresh
                } else {
                    alert("Error: " + j.message);
                }
            } catch(e) {
                alert("Comm Error: " + e);
            }
        }

        const canvas = document.getElementById('spectrum-canvas');
        const ctx = canvas.getContext('2d');
        const logBox = document.getElementById('log-list');
        
        // Network Viz Globals
        const netCanvas = document.getElementById('network-canvas');
        const netCtx = netCanvas.getContext('2d');
        let netNodes = [];
        let netLinks = [];

        // Resize Canvas
        function resize() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            netCanvas.width = netCanvas.offsetWidth;
            netCanvas.height = netCanvas.offsetHeight;
        }
        window.addEventListener('resize', resize);
        // Delay initial resize to ensure layout is done
        setTimeout(resize, 100);

        function escapeAttr(value) {
            return String(value)
                .replace(/&/g, '&amp;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
        }

        function escapeHtml(value) {
            return String(value)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
        }

        // Polling Status
        async function fetchStatus() {
            try {
                const res = await fetch('/api/status');
                const data = await res.json();

                const setText = (id, value) => {
                    const el = document.getElementById(id);
                    if (el) el.innerText = value;
                };
                
                // RAM Percentage
                let ramText = Math.round(data.heap_free/1024) + "k";
                if(data.heap_size) {
                    const pct = Math.round(((data.heap_size - data.heap_free) / data.heap_size) * 100);
                    ramText = pct + "% (" + ramText + " free)";
                }

                setText('stat-ram', ramText);
                setText('stat-uptime', Math.round(data.uptime/1000) + "s");
                setText('stat-plugin', data.plugin || "None");
                
                // Update Local Device State
                if(data.hostname) myDevice.hostname = data.hostname;
                myDevice.description = data.description || "";
                myDevice.status = data.status || "Unknown";
                myDevice.cluster = data.clusterName || "Default"; // Backend provides clusterName
                myDevice.timezone = data.timezone || "America/Los_Angeles";
                myDevice.task = data.task || "Unknown Task";
                myDevice.lastProbe = Date.now(); // Self is always fresh

                // Populate Config Form (only if not focused to avoid overwriting user typing)
                const actEl = document.activeElement;
                const descEl = document.getElementById('cfg-desc');
                const hostEl = document.getElementById('cfg-hostname');
                const clusterEl = document.getElementById('cfg-cluster');
                const tzEl = document.getElementById('cfg-timezone');
                if (descEl && actEl.id !== 'cfg-desc') descEl.value = myDevice.description;
                if (hostEl && actEl.id !== 'cfg-hostname') hostEl.value = myDevice.hostname;
                if (clusterEl && actEl.id !== 'cfg-cluster') clusterEl.value = myDevice.cluster;
                if (tzEl && actEl.id !== 'cfg-timezone') tzEl.value = myDevice.timezone;

                setText('connection-status', "ONLINE");
                const connEl = document.getElementById('connection-status');
                if (connEl) connEl.classList.add('active');

                // Mock Cluster Status update (backend not ready yet)
                // In future: data.clusterName and data.clusterTask
                const taskDesc = (data.plugin === "Scanner") ? "Broadband Sweep (Custom) ‚ú®" 
                               : (data.plugin === "RadioTest") ? "Hardware Verification ‚ú®"
                               : (data.plugin === "SystemIdle") ? "Searching for cluster friends üëÄ"
                               : "Idle ‚ú®";
                
                setText('cluster-status', `Current Cluster: ${data.clusterName || "Default"} ‚ú® Working On: ${taskDesc}`);

                // Auto-Reload on Firmware Update
                if (data.build_id) {
                    if (currentBuildId === null) {
                        currentBuildId = data.build_id;
                        console.log("Registered Build ID:", currentBuildId);
                    } else if (currentBuildId !== data.build_id) {
                        console.log("New Firmware Detected! Reloading...");
                        window.location.reload();
                    }
                }

                // --- PROCESS QUEUE STATUS ---
                if (data.queue && data.queue.current) {
                    const q = data.queue.current;
                    setText('q-task', q.task || "Idle");
                    setText('q-plugin', q.plugin || "SystemIdle");
                    setText('q-duration', q.duration > 0 ? q.duration + "ms" : "Indefinite");
                    setText('q-elapsed', (q.elapsed || 0) + "ms");
                    setText('q-depth', data.queue.depth || 0);
                }

                // --- PROCESS LED STATUS ---
                if (data.led) {
                    const ledEl = document.getElementById('led-indicator');
                    if (data.led.power && data.led.color) {
                        const { r, g, b } = data.led.color;
                        ledEl.style.backgroundColor = `rgb(${r},${g},${b})`;
                        ledEl.style.boxShadow = `0 0 8px rgb(${r},${g},${b})`;
                    } else {
                        ledEl.style.backgroundColor = '#000';
                        ledEl.style.boxShadow = 'none';
                    }
                }

                // --- PROCESS AGGREGATED DATA ---
                
                // 1. Logs (Safe DOM Update)
                if (data.logs && Array.isArray(data.logs)) {
                     // Clear safely
                     while(logBox.firstChild) logBox.removeChild(logBox.firstChild);
                     // Append safely
                     data.logs.forEach(msg => {
                         const el = document.createElement('div');
                         el.className = 'log-entry';
                         el.textContent = (typeof msg === 'string') ? msg : JSON.stringify(msg);
                         logBox.appendChild(el);
                     });
                     logBox.scrollTop = logBox.scrollHeight;
                }

                // 2. Peers
                if (data.peers && Array.isArray(data.peers)) {
                    // Trigger Crawl First (Data Logic)
                    if(!isCrawling) {
                        try { crawlNetwork(data.peers); } catch(e) { console.warn("Crawl Skipped", e); }
                    }

                    // Render Second (UI Logic)
                    if (!document.querySelector('.rename-input')) {
                        try {
                            renderPeerList(data.peers);
                        } catch(e) {
                             console.error("Peer Render Failed", e);
                        }
                    }
                }

            } catch(e) {
                console.warn("Status Fetch Error", e);
                    const stat = document.getElementById('connection-status');
                    if (stat) {
                        stat.innerText = "OFFLINE";
                        stat.classList.remove('active');
                    }
            }
        }
        setInterval(fetchStatus, 2000);
        fetchStatus();

        // Fetch Peers & Crawl
        let isCrawling = false;
        
        // Removed dedicated fetchPeers() polling loop
        // Removed dedicated fetchLogs() polling loop

        function renderPeerList(peers) {
             const container = document.getElementById('cluster-tree');
                
            // Merge Self into Peer List for unified rendering
            const allNodes = [ myDevice, ...peers ];
            
            // Group by Cluster
            const clusters = {};
            allNodes.forEach(p => {
                // Normalize cluster name
                let c = p.cluster;
                if (!c || c === "") c = "Default";
                
                if(!clusters[c]) clusters[c] = [];
                clusters[c].push(p);
            });
            
            // Build HTML
            let html = "";
            const sortedKeys = Object.keys(clusters).sort();
            
            for (const cName of sortedKeys) {
                const cPeers = clusters[cName];
                const isMyCluster = (cName === myDevice.cluster);
                const headerColor = isMyCluster ? "var(--success-color)" : "#bb86fc";
                const suffix = isMyCluster ? " (Local)" : "";
                
                html += `<div class="cluster-root" style="color:${headerColor}">${cName}${suffix}</div>`;

                html += cPeers.map(p => {
                        const isMe = (p.ip === myDevice.ip);
                        const link = `http://${(p.hostname || p.ip).toLowerCase()}.local`;
                        const alternateLink = `http://${p.ip}`; 
                        
                        // Prefer Hostname (mDNS) over IP
                        const finalLink = (p.hostname && p.hostname !== "Unknown") ? link : alternateLink;

                        const statusColor = (p.status && (p.status.startsWith("Ready") || p.status.startsWith("Working"))) ? 'var(--success-color)' : 
                                        (p.status && p.status.startsWith("Error")) ? 'var(--danger-color)' : '#666';
                        
                        const taskStr = p.task || "Unknown Task";
                        const safeDesc = escapeHtml(p.description || "");
                        const safeHost = escapeHtml(p.hostname || "Unknown");
                        const nameDisplay = p.description 
                            ? `<div style="line-height:1.2;">${safeDesc}</div><div style="font-size:0.75rem; color:#666;">${safeHost}</div>` 
                            : safeHost;
                        
                        // ID for in-place edit
                        const nodeId = "node-" + (p.ip || "unknown").replace(/\./g, '-');

                        return `
                    <div class="tree-node" id="${nodeId}">
                        <div class="device-node" style="${isMe ? 'border:1px solid #333;' : ''}">
                            <div data-action="open-node" data-link="${escapeAttr(finalLink)}" style="cursor:pointer; display:flex; align-items:center; flex:1;" title="Task: ${escapeAttr(taskStr)} | Click to open dashboard">
                                <span class="node-name-label" style="color:${isMe ? 'white':'#aaa'}; font-weight:bold;">${nameDisplay}</span>
                            </div>
                            
                            <span class="edit-icon" data-action="rename" data-node-id="${escapeAttr(nodeId)}" data-ip="${escapeAttr(p.ip || "")}" data-desc="${escapeAttr(p.description || "")}" data-hostname="${escapeAttr(p.hostname || "")}" title="Rename Node">‚úèÔ∏è</span>

                            <span style="margin-left:10px; font-size: 0.8rem; color:#888;">${taskStr}</span>
                            <span style="margin-left:5px; font-size: 0.8rem; color:${p.online ? statusColor : '#666'}">[${p.online ? (p.status || 'Active') : 'Offline'}]</span>
                            <div style="flex:0.1"></div>
                            <span style="color:#444; font-size:0.8rem;">${isMe ? "(This Device)" : p.ip}</span>
                        </div>
                    </div>
                `}).join('');
            }
            // Only update if changed to prevent hover flicker
            if (container.innerHTML !== html) {
                container.innerHTML = html;
            }
        }

        async function crawlNetwork(localPeers) {
            isCrawling = true;
            const nodeMap = new Map();
            const links = [];

            // Add Self
            nodeMap.set(myDevice.hostname, myDevice);

            // Add Local Peers (Degree 1) and Links from Me -> Them
            localPeers.forEach(p => {
                nodeMap.set(p.hostname, p);
                links.push({ source: myDevice.hostname, target: p.hostname });
            });

            // Fetch Degree 2 (Peers of Peers)
            // This allows us to see connections between my peers
            const promises = localPeers.map(async (p) => {
                if (!p.ip) return;
                try {
                    const controller = new AbortController();
                    const id = setTimeout(() => controller.abort(), 2000); // 2s Timeout
                    
                    const res = await fetch(`http://${p.ip}/api/peers`, { signal: controller.signal });
                    clearTimeout(id);
                    
                    if (res.ok) {
                        const remotePeers = await res.json();
                        remotePeers.forEach(rp => {
                            // Link p -> rp
                            links.push({ source: p.hostname, target: rp.hostname });

                            // If we haven't seen this node, it's a Degree 2 node
                            if (!nodeMap.has(rp.hostname)) {
                                rp.degree = 2; 
                                nodeMap.set(rp.hostname, rp);
                            }
                        });
                    }
                } catch (e) {
                    // Peer might be offline or CORS blocked (if old firmware)
                    // console.warn("Crawl failed for", p.hostname); 
                }
            });

            await Promise.all(promises);
            
            updateNetworkGraph(Array.from(nodeMap.values()), links);
            isCrawling = false;
        }

        // --- Force Directed Graph Logic ---
        
        function updateNetworkGraph(nodes, externalLinks) {
            // nodes is [ {hostname, cluster, status...}, ... ]
            
            // 1. Map current netNodes to a map for lookup (preserve positions)
            const existing = new Map(netNodes.map(n => [n.id, n]));
            
            // 2. Build new node list
            netNodes = nodes.map(n => {
                const id = n.hostname;
                const old = existing.get(id);
                // Random position start if new
                const x = old ? old.x : (netCanvas.width/2 + (Math.random()-0.5)*50);
                const y = old ? old.y : (netCanvas.height/2 + (Math.random()-0.5)*50);
                
                return {
                    id: id,
                    x: x,
                    y: y,
                    vx: old ? old.vx : 0,
                    vy: old ? old.vy : 0,
                    data: n
                };
            });

            // 3. Build Links
            if (externalLinks) {
                // Use crawled links
                netLinks = externalLinks;
            } else {
                // Fallback: Star Topology
                netLinks = [];
                const centerId = myDevice.hostname;
                netNodes.forEach(n => {
                    if (n.id !== centerId) {
                        netLinks.push({ source: centerId, target: n.id });
                    }
                });
            }
        }

        function runForceSimulation() {
            if(!netNodes.length) {
                requestAnimationFrame(runForceSimulation);
                return;
            }

            const width = netCanvas.width;
            const height = netCanvas.height;
            const k = 100; // ideal distance
            
            // 0. Center Forces (Gravity)
            const cx = width / 2;
            const cy = height / 2;

            // Physics Step
            netNodes.forEach(n => {
                // Repulsion (Coulomb)
                netNodes.forEach(other => {
                    if (n !== other) {
                        const dx = n.x - other.x;
                        const dy = n.y - other.y;
                        const distSq = dx*dx + dy*dy;
                        const dist = Math.sqrt(distSq) || 1;
                        const force = 2000 / distSq; // Repulsion strength
                        n.vx += (dx / dist) * force;
                        n.vy += (dy / dist) * force;
                    }
                });

                // Center Gravity (weak)
                n.vx += (cx - n.x) * 0.005;
                n.vy += (cy - n.y) * 0.005;

                // Cluster Gravity (Group similar clusters)
                // TODO: Find center of mass of cluster? 
                // Simple version: Nodes in same cluster attract slightly
                /*
                netNodes.forEach(other => {
                    if (n !== other && n.data.cluster === other.data.cluster) {
                        const dx = other.x - n.x;
                        const dy = other.y - n.y;
                         n.vx += dx * 0.001;
                         n.vy += dy * 0.001;
                    }
                });
                */
            });

            // Link Attraction (Spring)
            netLinks.forEach(l => {
                // Find node objects
                const s = netNodes.find(n => n.id === l.source);
                const t = netNodes.find(n => n.id === l.target);
                if (s && t) {
                    const dx = t.x - s.x;
                    const dy = t.y - s.y;
                    const dist = Math.sqrt(dx*dx + dy*dy) || 1;
                    const force = (dist - k) * 0.05; // Spring constant
                    
                    const fx = (dx / dist) * force;
                    const fy = (dy / dist) * force;
                    
                    s.vx += fx;
                    s.vy += fy;
                    t.vx -= fx;
                    t.vy -= fy;
                }
            });

            // Integration & Bounds
            netNodes.forEach(n => {
                n.vx *= 0.8; // Friction
                n.vy *= 0.8;
                
                // Max speed clamp
                const speed = Math.sqrt(n.vx*n.vx + n.vy*n.vy);
                if(speed > 10) {
                    n.vx = (n.vx/speed)*10;
                    n.vy = (n.vy/speed)*10;
                }

                n.x += n.vx;
                n.y += n.vy;

                // Wall bounce
                if(n.x < 20) { n.x = 20; n.vx *= -0.5; }
                if(n.x > width-20) { n.x = width-20; n.vx *= -0.5; }
                if(n.y < 20) { n.y = 20; n.vy *= -0.5; }
                if(n.y > height-20) { n.y = height-20; n.vy *= -0.5; }
            });

            // Draw
            netCtx.clearRect(0, 0, width, height);

            // Draw Links
            netCtx.strokeStyle = '#333';
            netCtx.lineWidth = 1;
            netCtx.beginPath();
            netLinks.forEach(l => {
                const s = netNodes.find(n => n.id === l.source);
                const t = netNodes.find(n => n.id === l.target);
                if (s && t) {
                    netCtx.moveTo(s.x, s.y);
                    netCtx.lineTo(t.x, t.y);
                }
            });
            netCtx.stroke();

            // Draw Nodes
            netNodes.forEach(n => {
                netCtx.beginPath();
                netCtx.arc(n.x, n.y, 8, 0, 2 * Math.PI);
                
                // Color by Status/Self
                if (n.data.isSelf) netCtx.fillStyle = '#03dac6'; // Cyan
                else if (n.data.online) netCtx.fillStyle = '#bb86fc'; // Purple
                else netCtx.fillStyle = '#444'; // Gray
                
                netCtx.fill();
                netCtx.strokeStyle = '#000';
                netCtx.lineWidth = 2;
                netCtx.stroke();

                // Labels
                netCtx.fillStyle = '#fff';
                netCtx.font = '10px Consolas';
                const label = n.data.description ? n.data.description : n.id;
                netCtx.fillText(label, n.x + 10, n.y + 3);
            });

            requestAnimationFrame(runForceSimulation);
        }
        
        // Start Sim
        runForceSimulation();

        // Canvas Interaction (Click to Visit)
        netCanvas.addEventListener('click', (e) => {
            const rect = netCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Check collision with nodes
            for (const n of netNodes) {
                const dx = mouseX - n.x;
                const dy = mouseY - n.y;
                // Hit radius 12 (drawn radius is 8)
                if (dx*dx + dy*dy < 144) { 
                    const p = n.data;
                    const link = `http://${(p.hostname || p.ip).toLowerCase()}.local`;
                    const alternateLink = `http://${p.ip}`; 
                    const finalLink = (p.hostname && p.hostname !== "Unknown") ? link : alternateLink;
                    window.location.href = finalLink;
                    break;
                }
            }
        });

        // Mouse Move for Cursor
        netCanvas.addEventListener('mousemove', (e) => {
            const rect = netCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            let hover = false;
            for (const n of netNodes) {
                const dx = mouseX - n.x;
                const dy = mouseY - n.y;
                if (dx*dx + dy*dy < 144) {
                    hover = true;
                    break;
                }
            }
            netCanvas.style.cursor = hover ? 'pointer' : 'default';
        });

        // --- Apply Manual Override ---
        async function startManualScan() {
            const start = document.getElementById('scan-start-freq').value;
            const stop = document.getElementById('scan-stop-freq').value;
            const continuous = document.getElementById('scan-continuous').checked;

            try {
                // Placeholder for real scan task
                alert("Starting Scan\nStart: " + start + "\nStop: " + stop + "\nContinuous: " + continuous);
                /* 
                await fetch('/api/task', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ plugin: "ManualScan", params: { start, stop, continuous } }) 
                });
                */
            } catch(e) {
                alert("Start Failed: " + e);
            }
        }

        async function stopManualScan() {
             try {
                 await fetch('/api/task', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ plugin: "SystemIdle" }) 
                });
                alert("Scan Stopped (Idle)");
            } catch(e) {
                alert("Stop Failed: " + e);
            }
        }

        // --- Event Binding (CSP Safe) ---
        function bindEvents() {
            function safeBind(id, handler) {
                const el = document.getElementById(id);
                if(el) {
                    el.onclick = handler;
                    el.style.cursor = 'pointer'; // Ensure visual cue
                }
            }

            // Headers
            safeBind('btn-tab-clusters', () => switchTab('clusters'));
            safeBind('btn-tab-task', () => switchTab('task'));
            safeBind('btn-tab-logs', () => switchTab('logs'));

            // Sub-tabs
            safeBind('btn-task-device', () => switchTaskSubTab('device'));
            safeBind('btn-task-task', () => switchTaskSubTab('task'));
            safeBind('btn-log-tail', () => switchLogMode('tail'));
            safeBind('btn-log-head', () => switchLogMode('head'));

            // Actions
            safeBind('btn-scan-start', startManualScan);
            safeBind('btn-scan-stop', stopManualScan);
            safeBind('btn-update-identity', applyIdentity);
            safeBind('led-indicator', configureLed);

            // Cluster Tree Delegation
            const tree = document.getElementById('cluster-tree');
            if(tree) {
                tree.onclick = (e) => {
                    const renameEl = e.target.closest('[data-action="rename"]');
                    if (renameEl) {
                        e.stopPropagation();
                        startRename(
                            renameEl.dataset.nodeId,
                            renameEl.dataset.ip,
                            renameEl.dataset.desc || "",
                            renameEl.dataset.hostname || ""
                        );
                        return;
                    }

                    const openEl = e.target.closest('[data-action="open-node"]');
                    if (openEl && openEl.dataset.link) {
                        window.location.href = openEl.dataset.link;
                    }
                };
            }
        }
        
        // Run Bindings
        bindEvents();

        // --- Inline Renaming Logic ---
        function startRename(nodeId, ip, currentDesc, hostname) {
            const nodeEl = document.getElementById(nodeId);
            if(!nodeEl) return;

            const nameArea = nodeEl.querySelector('.node-name-label');
            if(!nameArea) return;
            
            // Avoid double-edit
            if(nameArea.querySelector('input')) return;

            // Save old content
            const oldHtml = nameArea.innerHTML;

            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentDesc;
            input.placeholder = hostname;
            input.className = 'rename-input';
            
            // Interaction
            input.onkeydown = (e) => {
                if(e.key === 'Enter') {
                     input.disabled = true; 
                     input.classList.remove('rename-input'); // Allow polling to resume
                     saveNodeName(ip, input.value);
                }
                if(e.key === 'Escape') {
                    nameArea.innerHTML = oldHtml;
                }
                e.stopPropagation(); // prevent tree click
            };
            input.onclick = (e) => e.stopPropagation();
            
            nameArea.innerHTML = '';
            nameArea.appendChild(input);
            input.focus();
        }

        async function saveNodeName(ip, newDesc) {
            try {
                // Cross-Origin Request to the target node
                // Requires the target node to support CORS headers (Config.cpp/WebServer.cpp likely handles this globally or limited)
                const targetUrl = `http://${ip}/api/config`; 
                
                const res = await fetch(targetUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ description: newDesc }) 
                });
                
                if(!res.ok) throw new Error("Node rejected update");
                
                // Refresh list
                setTimeout(fetchStatus, 500);
                
            } catch(e) {
                alert("Failed to update remote node: " + e.message + "\n(Ensure nodes are on same version)");
            }
        }

        // Dummy Viz
        function drawPattern() {
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.fillRect(0,0,canvas.width, canvas.height);
            
            ctx.fillStyle = '#03dac6';
            const h = canvas.height;
            const w = canvas.width;
            
            // Draw grid
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for(let x=0; x<w; x+=50) { ctx.moveTo(x,0); ctx.lineTo(x,h); }
            ctx.stroke();

            for(let i=0; i<w; i+=10) {
                const noise = Math.random() * (h * 0.8);
                ctx.fillRect(i, h - noise, 8, noise);
            }
            requestAnimationFrame(drawPattern);
        }
        drawPattern();

        // Init Tab
        switchTab('clusters');
    </script>
