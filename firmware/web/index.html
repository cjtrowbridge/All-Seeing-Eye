<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> ‚ú®üëÅ‚ú® All-Seeing Eye</title>
    <style>
        :root {
            --bg-color: #121212;
            --card-color: #1e1e1e;
            --text-color: #e0e0e0;
            --accent-color: #bb86fc;
            --danger-color: #cf6679;
            --success-color: #03dac6;
            --border-color: #333;
        }
        * { box-sizing: border-box; }
        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            display: grid;
            grid-template-rows: auto 1fr auto auto; /* Header, Main, Controls, Footer */
            height: 100vh;
            overflow: hidden;
        }
        header {
            background-color: var(--panel-color);
            padding: 0 20px;
            height: 50px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
        }
        h1 { margin: 0; font-size: 1.1rem; display: flex; align-items: center; gap: 10px; font-weight: 500; letter-spacing: 1px; }
        .status-badge {
            background: #333;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            color: #aaa;
            text-transform: uppercase;
        }
        .status-badge.active { color: var(--bg-color); background: var(--success-color); font-weight: bold; }
        
        main {
            display: grid;
            grid-template-rows: 1fr auto; /* Content, Viz */
            overflow: hidden;
            position: relative;
        }

        /* Layout System */
        #layout-grid {
            display: grid;
            grid-template-columns: 1fr; /* Mobile Default */
            overflow: hidden;
            height: 100%;
        }

        .layout-col {
            overflow-y: auto;
            display: none; /* Hidden by default on mobile (handled by tabs) */
            flex-direction: column;
            background: #141414;
        }
        .layout-col.active { display: flex; }

        .col-header {
            background: #1a1a1a;
            padding: 10px 15px;
            font-size: 0.9rem;
            text-transform: uppercase;
            color: #888;
            border-bottom: 1px solid #333;
            font-weight: bold;
            display: flex; justify-content: space-between; align-items: center;
            min-height: 42px;
        }

        /* Desktop Overrides */
        @media (min-width: 1000px) {
            #layout-grid {
                grid-template-columns: 1fr 1fr 1fr; /* Left (Env), Center (Tools), Right (Work) */
            }
            .mobile-tabs { display: none !important; }
            .layout-col {
                border-right: 1px solid var(--border-color);
                display: flex !important; /* Force show all columns on desktop */
            }
            .layout-col:last-child { border-right: none; }
        }

        #log-panel {
            flex: 1;
            padding: 10px;
            overflow-y: auto;
            font-family: 'Consolas', monospace;
            font-size: 0.85rem;
            color: #ccc;
            background: #000;
        }
        .log-entry { margin-bottom: 4px; border-bottom: 1px solid #222; padding-bottom: 2px; text-wrap: wrap; word-break: break-all; }
        
        /* Mobile Tabs */
        .mobile-tabs {
            display: flex;
            background: #1a1a1a;
            border-bottom: 1px solid var(--border-color);
        }
        .tab-btn {
            flex: 1;
            padding: 12px;
            cursor: pointer;
            border: none;
            background: transparent;
            color: #888;
            border-bottom: 2px solid transparent;
            font-size: 0.9rem;
            text-transform: uppercase;
        }
        .tab-btn.active {
            border-bottom: 2px solid #bb86fc;
            color: #bb86fc;
            background: #202020;
        }
        
        /* INTERNAL TABS (Inside Columns) */
        .sub-tabs {
            display: flex;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
        }
        .sub-tab-btn {
            flex: 1;
            background: none;
            border: none;
            color: #666;
            padding: 8px;
            cursor: pointer;
            font-size: 0.8rem;
            text-transform: uppercase;
            border-bottom: 2px solid transparent;
        }
        .sub-tab-btn:hover { color: #aaa; background: #222; }
        .sub-tab-btn.active {
            color: var(--accent-color);
            border-bottom: 2px solid var(--accent-color);
            background: #252525;
        }
        
        .sub-tab-content {
            display: none;
            flex-direction: column;
            padding: 15px;
            overflow-y: auto;
            flex: 1;
        }
        .sub-tab-content.active { display: flex; }

        .led-circle {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background-color: #000;
            border: 1px solid #555;
            cursor: pointer;
            box-shadow: 0 0 2px rgba(0,0,0,0.5);
            transition: all 0.3s ease;
        }
        .led-circle:hover { transform: scale(1.2); }
        
        /* Persistent Viz Panel */
        #viz-panel {
            height: 150px; 
            background: #000;
            position: relative;
            border-top: 1px solid var(--border-color);
        }
        
        #spectrum-canvas { width: 100%; height: 100%; display: block; }
        #network-canvas { width: 100%; height: 100%; display: block; }

        /* Network Map */
        #network-map-container {
            height: 250px;
            background: #0a0a0a;
            border-bottom: 1px solid var(--border-color);
            position: relative;
            overflow: hidden;
        }

        /* Controls */
        .controls-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            background: #222;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #333;
        }
        
        .control-group { display: flex; flex-direction: column; gap: 5px; }
        
        label { font-size: 0.7rem; color: #888; text-transform: uppercase; }
        input, select {
            background: #111;
            border: 1px solid #444;
            color: white;
            padding: 6px 10px;
            border-radius: 3px;
            font-size: 0.9rem;
        }
        button { 
            background: var(--accent-color); 
            color: black; 
            font-weight: bold; 
            cursor: pointer; 
            border: none;
            padding: 8px 16px;
            border-radius: 3px;
            text-transform: uppercase;
            font-size: 0.8rem;
        }
        button:hover { opacity: 0.9; }

        footer {
            background: #0e0e0e;
            padding: 5px 20px;
            font-size: 0.75rem;
            color: #666;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .stat-item { margin-right: 15px; }
        .stat-val { color: #888; margin-left: 5px; }
        
        /* Tree View */
        .tree-node { margin-left: 10px; padding: 2px 0; }
        .cluster-root { font-weight: bold; color: var(--success-color); margin-bottom: 5px; padding-left:10px; margin-top:10px; }
        .device-node { color: #aaa; display: flex; gap: 10px; padding: 6px; background: #1a1a1a; margin-bottom: 2px; border-radius: 0; border-bottom:1px solid #222; }
        .device-node:hover { background: #252525; cursor: pointer; }

        .device-node .edit-icon { opacity: 0; cursor: pointer; margin-left:10px; font-size: 1.1em; color: #888; }
        .device-node:hover .edit-icon { opacity: 1; }
        .rename-input { background: #333; color: white; border: 1px solid #555; padding: 2px 5px; width:120px; }

        /* Task Catalog */
        .task-catalog-container { height:100%; overflow-y:auto; padding:10px; }
        .task-btn {
            display: block;
            width: 100%;
            background: #1e1e1e;
            color: #ccc;
            border: 1px solid #333;
            text-align: left;
            padding: 12px 15px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
            border-left: 3px solid transparent;
        }
        .task-btn:hover { background: #252525; color: #fff; border-left: 3px solid var(--accent-color); }
        .task-btn.selected { background: #2a2a2a; border-left: 3px solid var(--success-color); color:white; }
        .task-btn .name { font-weight: bold; display: block; color: var(--accent-color); }
        .task-btn .desc { display: block; font-size: 0.8rem; color: #888; margin-top: 4px; }

        /* Form & Exec */
        #task-form-container { padding: 20px; width: 100%; max-width: 600px; margin:0 auto; }
        .form-header { margin-bottom: 20px; border-bottom: 1px solid #333; padding-bottom: 10px; }
        .form-title { font-size: 1.4rem; margin: 0; color: var(--accent-color); }
        .form-desc { font-size: 0.95rem; color: #aaa; margin-top: 5px; line-height: 1.4; }
        .form-group { margin-bottom: 20px; }
        .form-label { display: block; margin-bottom: 8px; font-size: 0.85rem; color: #bbb; letter-spacing: 0.5px; }
        .form-input, .form-select { 
            width: 100%; padding: 10px; background: #0a0a0a; border: 1px solid #444; color: #fff; 
            font-size:1rem; 
        }
        .form-check-label { margin-left: 10px; color:#ddd; font-size:0.9rem; }
        
        .cta-button {
            width:100%; padding:15px; font-size:1rem; letter-spacing:1px;
            background: var(--success-color); color:#000; font-weight:bold; border-radius:4px;
            margin-top:20px; transition: opacity 0.2s;
        }
        .cta-button:hover { opacity:0.9; box-shadow: 0 0 10px rgba(3,218,198,0.3); }

        /* Execution Spinner */
        #task-execution-state { text-align: center; padding: 40px; }
        .spinner { 
            width: 50px; height: 50px; border: 4px solid #333; border-top: 4px solid var(--accent-color); 
            border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 20px; 
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Empty State */
        .empty-state {
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            height: 100%; color: #444; text-align: center;
        }
        .empty-icon { font-size: 3rem; margin-bottom: 15px; opacity: 0.2; }
    </style>
</head>
<body>
    <header>
        <h1>
            <span>‚ú®üëÅÔ∏è‚ú®</span> All-Seeing Eye 
            <span id="connection-status" class="status-badge">DISCONNECTED</span>
            <span id="cluster-status" style="font-size: 0.8rem; color: #888; font-weight: normal; margin-left: 10px;">
                ‚ú® Current Cluster: Default ‚ú® Working On: Idle ‚ú®
            </span>
            <span style="font-size: 0.8rem; color: #888; margin-left: 10px;">‚ú®</span>
            <div id="led-indicator" class="led-circle" title="LED Status: Click to configure"></div>
        </h1>
    </header>

    <main>
        <!-- Mobile Navigation Tabs (Hidden on Desktop) -->
        <div class="mobile-tabs">
            <button id="mob-btn-env" class="tab-btn active" onclick="switchMobileCol('env')">Cluster & Logs</button>
            <button id="mob-btn-ctrl" class="tab-btn" onclick="switchMobileCol('ctrl')">Tasks</button>
            <button id="mob-btn-work" class="tab-btn" onclick="switchMobileCol('work')">Monitor</button>
        </div>

        <div id="layout-grid">
            <!-- COLUMN 1: ENVIRONMENT & LOGS -->
            <div id="col-env" class="layout-col active">
                <div class="col-header">Cluster Overview</div>
                
                <div id="cluster-tree" style="padding-bottom:10px;">
                    <div style="text-align:center; padding:20px; color:#666;">Loading Cluster Matrix...</div>
                </div>

                 <!-- Network Map -->
                <div id="network-map-container">
                    <canvas id="network-canvas"></canvas>
                    <div style="position:absolute; bottom:5px; right:10px; font-size:0.7rem; color:#444;">Topology Preview</div>
                </div>

                <div class="col-header" style="margin-top:auto;">System Logs</div>
                <div class="sub-tabs">
                    <button id="btn-log-tail" class="sub-tab-btn active">Tail (Live)</button>
                    <button id="btn-log-head" class="sub-tab-btn">Head (Boot)</button>
                </div>
                
                <div id="log-container-tail" class="sub-tab-content active" style="padding:0; flex:1; min-height:200px;">
                    <div id="log-list" style="padding:10px; font-family:'Consolas', monospace; font-size:0.8rem; color:#ccc;">
                        <div style="text-align:center; color:#444; margin-top:20px;">Waiting for live logs...</div>
                    </div>
                </div>

                <div id="log-container-head" class="sub-tab-content" style="padding:0; flex:1; min-height:200px;">
                    <div id="log-list-head" style="padding:10px; font-family:'Consolas', monospace; font-size:0.8rem; color:#ccc;">
                        <div style="text-align:center; color:#444; margin-top:20px;">Loading startup logs...</div>
                    </div>
                </div>
            </div>

            <!-- COLUMN 2: CONTROLS & DEVICE -->
            <div id="col-ctrl" class="layout-col">
                <div class="sub-tabs">
                    <button id="btn-sub-tasks" class="sub-tab-btn active" onclick="switchControlTab('tasks')">Task List</button>
                    <button id="btn-sub-device" class="sub-tab-btn" onclick="switchControlTab('device')">Device Config</button>
                </div>

                <!-- View: Task Catalog -->
                <div id="view-tasks" class="sub-tab-content active" style="padding:0;">
                    <div id="task-catalog-container" class="task-catalog-container">
                        <div style="padding:20px; color:#666; text-align:center;">Loading catalog...</div>
                    </div>
                </div>

                <!-- View: Device Settings -->
                <div id="view-device" class="sub-tab-content">
                     <div class="controls-container" style="border:none; background:transparent;">
                        <div class="control-group">
                            <label>Friendly Name</label>
                            <input type="text" id="cfg-desc" placeholder="e.g. Kitchen Node">
                        </div>
                        <div class="control-group">
                            <label>Hostname</label>
                            <input type="text" id="cfg-hostname" placeholder="ase-xxxx">
                        </div>
                        <div class="control-group">
                            <label>Cluster Group</label>
                            <input type="text" id="cfg-cluster" placeholder="Default">
                        </div>
                         <div class="control-group">
                            <label>Timezone</label>
                            <input type="text" id="cfg-timezone" placeholder="America/Los_Angeles">
                        </div>
                        <button id="btn-update-identity" style="margin-top:15px; width:100%;">UPDATE IDENTITY</button>
                        
                        <div style="margin-top:30px; padding:15px; background:#1a1a1a; border-radius:4px;">
                             <strong>Cluster Strategy:</strong> Independent<br>
                             <small style="color:#666;">This node is currently operating independently.</small>
                        </div>
                    </div>
                </div>
            </div>

            <!-- COLUMN 3: WORKSPACE & EXECUTION -->
            <div id="col-work" class="layout-col">
                
                <!-- State 1: Intro -->
                <div id="work-intro" class="empty-state">
                    <div class="empty-icon">‚ö°</div>
                    <h3>Ready for Instructions</h3>
                    <p style="font-size:0.9rem; max-width:200px;">Select a mission from the list to configure and launch.</p>
                </div>

                <!-- State 2: Configuration Form -->
                <div id="work-form" style="display:none;">
                     <div style="padding:15px; border-bottom:1px solid #333; display:flex; justify-content:space-between; align-items:center;">
                        <span style="font-size:0.8rem; text-transform:uppercase; color:#666;">Configuration</span>
                        <button class="btn-cancel" onclick="resetWorkspace()" style="font-size:0.8rem; padding:4px 8px;">Cancel</button>
                     </div>
                     <form id="task-form-container" onsubmit="return false;">
                        <!-- Dynamic Form Injected Here -->
                     </form>
                </div>

                <!-- State 3: Execution Running -->
                <div id="work-running" style="display:none; flex-direction:column; align-items:center; justify-content:center; height:100%;">
                    <div class="spinner"></div>
                    <h2 style="color:var(--accent-color); margin-bottom:5px;">Mission Active</h2>
                    <p id="execution-status-text" style="color:#aaa;">Initiating logic chain...</p>
                    
                    <div id="execution-timer" style="font-family:monospace; font-size:2rem; margin:20px 0; color:#fff;">00:00:00</div>
                    
                    <div class="controls-container" style="min-width:250px;">
                        <div style="display:flex; justify-content:space-between;"><span>Task:</span> <span id="q-task-monitor" style="color:white">--</span></div>
                        <div style="display:flex; justify-content:space-between;"><span>Plugin:</span> <span id="q-plugin-monitor" style="color:white">--</span></div>
                    </div>

                    <button class="btn-cancel" onclick="abortTask()" style="margin-top:30px; border-color:var(--danger-color); color:var(--danger-color);">ABORT MISSION</button>
                </div>

                <!-- State 4: Results -->
                <div id="work-results" style="display:none;">
                    <!-- Placeholder for task completion -->
                </div>

            </div>
        </div>

        <!-- Persistent Viz -->
        <div id="viz-panel">
            <canvas id="spectrum-canvas"></canvas>
        </div>
    </main>


    <footer>
        <span class="stat-item">RAM: <span id="stat-ram" class="stat-val">--</span></span>
        <span class="stat-item">UPTIME: <span id="stat-uptime" class="stat-val">--</span></span>
        <span class="stat-item">PLUGIN: <span id="stat-plugin" class="stat-val">--</span></span>
        <span style="flex:1"></span>
        <span id="stat-version" style="opacity:0.5">v1.0</span>
    </footer>

    <script>
        // Mobile Column Switcher
        function switchMobileCol(colName) {
            document.querySelectorAll('.mobile-tabs .tab-btn').forEach(b => b.classList.remove('active'));
            const btn = document.getElementById('mob-btn-' + colName);
            if(btn) btn.classList.add('active');
            
            document.querySelectorAll('.layout-col').forEach(c => c.classList.remove('active'));
            const col = document.getElementById('col-' + colName);
            if(col) col.classList.add('active');
        }

        // Center Col Switcher
        function switchControlTab(mode) {
             const parent = document.getElementById('col-ctrl');
             parent.querySelectorAll('.sub-tab-btn').forEach(b => b.classList.remove('active'));
             parent.querySelectorAll('.sub-tab-content').forEach(c => c.classList.remove('active'));

             if(mode === 'tasks') {
                 document.getElementById('btn-sub-tasks').classList.add('active');
                 document.getElementById('view-tasks').classList.add('active');
             } else {
                 document.getElementById('btn-sub-device').classList.add('active');
                 document.getElementById('view-device').classList.add('active');
             }
        }

        // Log Switcher (Tail/Head)
        function switchLogMode(mode) {
            const parent = document.getElementById('col-env');
            document.getElementById('btn-log-tail').classList.toggle('active', mode === 'tail');
            document.getElementById('btn-log-head').classList.toggle('active', mode === 'head');
            
            document.getElementById('log-container-tail').classList.toggle('active', mode === 'tail');
            document.getElementById('log-container-head').classList.toggle('active', mode === 'head');

            if (mode === 'head') fetchHeadLogs();
        }

        let headLogsLoaded = false;
        async function fetchHeadLogs() {
            if (headLogsLoaded) return; // Only fetch once
            
            try {
                const res = await fetch('/api/logs/head');
                const logs = await res.json();
                const container = document.getElementById('log-list-head');
                
                 // Safe Clear
                 while(container.firstChild) container.removeChild(container.firstChild);

                if (Array.isArray(logs) && logs.length > 0) {
                     logs.forEach(l => {
                        const div = document.createElement('div');
                        div.className = 'log-entry';
                        div.textContent = l;
                        container.appendChild(div);
                     });
                } else {
                    const msg = document.createElement('div');
                    msg.style.textAlign = 'center';
                    msg.style.color = '#666';
                    msg.style.padding = '20px';
                    msg.textContent = 'No startup logs recorded.';
                    container.appendChild(msg);
                }
                headLogsLoaded = true;
            } catch(e) {
                console.error("Failed to fetch head logs", e);
                const c = document.getElementById('log-list-head');
                if(c) {
                    c.textContent = "Error loading logs.";
                    c.style.color = "var(--danger-color)";
                    c.style.padding = "20px";
                }
            }
        }

        // Task Sub-Tab Switcher
        function switchTaskSubTab(mode) {
             const parent = document.getElementById('tab-task');
             // Buttons
             parent.querySelectorAll('.sub-tab-btn').forEach(b => b.classList.remove('active'));
             // Containers
             parent.querySelectorAll('.sub-tab-content').forEach(c => c.classList.remove('active'));

             if (mode === 'device') {
                 parent.querySelectorAll('.sub-tab-btn')[0].classList.add('active');
                 document.getElementById('subtab-device').classList.add('active');
             } else {
                 parent.querySelectorAll('.sub-tab-btn')[1].classList.add('active');
                 document.getElementById('subtab-task').classList.add('active');
             }
        }

        // State
        const IP = window.location.hostname === "localhost" ? "allseeingeye.local" : window.location.hostname;
        // Local Device store
        let myDevice = { hostname: "Loading...", description: "", ip: IP, status: "Unknown", cluster: "Default", timezone: "America/Los_Angeles", online: true, isSelf: true };
        let currentBuildId = null; 
        
        // LED Config
        async function configureLed() {
            // Get current color from status (or just prompt empty)
            const input = prompt("Enter RGB values (e.g. 255,0,128)\nEnter 0,0,0 to disable LED.", "0,0,0");
            if (!input) return;

            const parts = input.split(',').map(s => parseInt(s.trim()));
            if(parts.length !== 3 || parts.some(isNaN)) {
                alert("Invalid format. Use r,g,b");
                return;
            }
            
            const [r,g,b] = parts;
            
            try {
                if(r===0 && g===0 && b===0) {
                    await fetch('/api/led/off', { method: 'POST' });
                } else {
                    // Update Color first (silent if off)
                    await fetch(`/api/led?r=${r}&g=${g}&b=${b}`);
                    // Then Turn On
                    await fetch('/api/led/on', { method: 'POST' });
                }
                // Refresh Page to show update
                window.location.reload();
            } catch(e) {
                alert("LED Control Failed: " + e);
            }
        }

        // Functions
        async function applyIdentity() {
            const desc = document.getElementById('cfg-desc').value;
            const host = document.getElementById('cfg-hostname').value;
            const clust = document.getElementById('cfg-cluster').value;
            const tz = document.getElementById('cfg-timezone').value;
            
            if(!host) return alert("Hostname is required");
            
            try {
                const res = await fetch('/api/config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        description: desc,
                        hostname: host,
                        cluster: clust,
                        timezone: tz
                    })
                });
                const j = await res.json();
                if(j.status === 'success') {
                    alert("Identity Updated. Rebooting may be required for Hostname changes.");
                                        alert("Identity Updated. Reboot may be required for Hostname/Timezone changes.");
                    fetchStatus(); // Refresh
                } else {
                    alert("Error: " + j.message);
                }
            } catch(e) {
                alert("Comm Error: " + e);
            }
        }

        const canvas = document.getElementById('spectrum-canvas');
        const ctx = canvas.getContext('2d');
        const logBox = document.getElementById('log-list');
        
        // Network Viz Globals
        const netCanvas = document.getElementById('network-canvas');
        const netCtx = netCanvas.getContext('2d');
        let netNodes = [];
        let netLinks = [];

        // Resize Canvas
        function resize() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            netCanvas.width = netCanvas.offsetWidth;
            netCanvas.height = netCanvas.offsetHeight;
        }
        window.addEventListener('resize', resize);
        // Delay initial resize to ensure layout is done
        setTimeout(resize, 100);

        function escapeAttr(value) {
            return String(value)
                .replace(/&/g, '&amp;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
        }

        function escapeHtml(value) {
            return String(value)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
        }

        // Polling Status
        async function fetchStatus() {
            try {
                const res = await fetch('/api/status');
                const data = await res.json();

                const setText = (id, value) => {
                    const el = document.getElementById(id);
                    if (el) el.innerText = value;
                };
                
                // RAM Percentage
                let ramText = Math.round(data.heap_free/1024) + "k";
                if(data.heap_size) {
                    const pct = Math.round(((data.heap_size - data.heap_free) / data.heap_size) * 100);
                    ramText = pct + "% (" + ramText + " free)";
                }

                setText('stat-ram', ramText);
                setText('stat-uptime', Math.round(data.uptime/1000) + "s");
                setText('stat-plugin', data.plugin || "None");
                
                // Update Local Device State
                if(data.hostname) myDevice.hostname = data.hostname;
                myDevice.description = data.description || "";
                myDevice.status = data.status || "Unknown";
                myDevice.cluster = data.clusterName || "Default"; // Backend provides clusterName
                myDevice.timezone = data.timezone || "America/Los_Angeles";
                myDevice.task = data.task || "Unknown Task";
                myDevice.lastProbe = Date.now(); // Self is always fresh

                // Populate Config Form (only if not focused to avoid overwriting user typing)
                const actEl = document.activeElement;
                const descEl = document.getElementById('cfg-desc');
                const hostEl = document.getElementById('cfg-hostname');
                const clusterEl = document.getElementById('cfg-cluster');
                const tzEl = document.getElementById('cfg-timezone');
                if (descEl && actEl.id !== 'cfg-desc') descEl.value = myDevice.description;
                if (hostEl && actEl.id !== 'cfg-hostname') hostEl.value = myDevice.hostname;
                if (clusterEl && actEl.id !== 'cfg-cluster') clusterEl.value = myDevice.cluster;
                if (tzEl && actEl.id !== 'cfg-timezone') tzEl.value = myDevice.timezone;

                setText('connection-status', "ONLINE");
                const connEl = document.getElementById('connection-status');
                if (connEl) connEl.classList.add('active');
                
                // --- PROCESS QUEUE STATUS (MONITOR) ---
                if (data.queue && data.queue.current) {
                    const q = data.queue.current;
                    // Update Monitor View if visible
                    setText('q-task-monitor', q.task || "Idle");
                    setText('q-plugin-monitor', q.plugin || "SystemIdle");
                    
                    // Update Execution Text if running
                    const execText = document.getElementById('execution-status-text');
                    if (execText && document.getElementById('work-running').style.display !== 'none') {
                         execText.textContent = `Running: ${q.plugin} (${q.elapsed}ms)`;
                    }
                }

                // --- PROCESS LED STATUS ---
                if (data.led) {
                    const ledEl = document.getElementById('led-indicator');
                    if (data.led.power && data.led.color) {
                        const { r, g, b } = data.led.color;
                        ledEl.style.backgroundColor = `rgb(${r},${g},${b})`;
                        ledEl.style.boxShadow = `0 0 8px rgb(${r},${g},${b})`;
                    } else {
                        ledEl.style.backgroundColor = '#000';
                        ledEl.style.boxShadow = 'none';
                    }
                }

                // --- PROCESS AGGREGATED DATA ---
                
                // 1. Logs (Safe DOM Update)
                if (data.logs && Array.isArray(data.logs)) {
                     // Clear safely
                     while(logBox.firstChild) logBox.removeChild(logBox.firstChild);
                     // Append safely
                     data.logs.forEach(msg => {
                         const el = document.createElement('div');
                         el.className = 'log-entry';
                         el.textContent = (typeof msg === 'string') ? msg : JSON.stringify(msg);
                         logBox.appendChild(el);
                     });
                     logBox.scrollTop = logBox.scrollHeight;
                }

                // 2. Peers
                if (data.peers && Array.isArray(data.peers)) {
                    // Trigger Crawl First (Data Logic)
                    if(!isCrawling) {
                        try { crawlNetwork(data.peers); } catch(e) { console.warn("Crawl Skipped", e); }
                    }

                    // Render Second (UI Logic)
                    if (!document.querySelector('.rename-input')) {
                        try {
                            renderPeerList(data.peers);
                        } catch(e) {
                             console.error("Peer Render Failed", e);
                        }
                    }
                }

            } catch(e) {
                console.warn("Status Fetch Error", e);
                    const stat = document.getElementById('connection-status');
                    if (stat) {
                        stat.innerText = "OFFLINE";
                        stat.classList.remove('active');
                    }
            }
        }
        setInterval(fetchStatus, 2000);
        fetchStatus();

        // Fetch Peers & Crawl
        let isCrawling = false;
        
        // Removed dedicated fetchPeers() polling loop
        // Removed dedicated fetchLogs() polling loop

        function renderPeerList(peers) {
             const container = document.getElementById('cluster-tree');
                
            // Merge Self into Peer List for unified rendering
            const allNodes = [ myDevice, ...peers ];
            
            // Group by Cluster
            const clusters = {};
            allNodes.forEach(p => {
                // Normalize cluster name
                let c = p.cluster;
                if (!c || c === "") c = "Default";
                
                if(!clusters[c]) clusters[c] = [];
                clusters[c].push(p);
            });
            
            // Build HTML
            let html = "";
            const sortedKeys = Object.keys(clusters).sort();
            
            for (const cName of sortedKeys) {
                const cPeers = clusters[cName];
                const isMyCluster = (cName === myDevice.cluster);
                const headerColor = isMyCluster ? "var(--success-color)" : "#bb86fc";
                const suffix = isMyCluster ? " (Local)" : "";
                
                html += `<div class="cluster-root" style="color:${headerColor}">${cName}${suffix}</div>`;

                html += cPeers.map(p => {
                        const isMe = (p.ip === myDevice.ip);
                        const link = `http://${(p.hostname || p.ip).toLowerCase()}.local`;
                        const alternateLink = `http://${p.ip}`; 
                        
                        // Prefer Hostname (mDNS) over IP
                        const finalLink = (p.hostname && p.hostname !== "Unknown") ? link : alternateLink;

                        const statusColor = (p.status && (p.status.startsWith("Ready") || p.status.startsWith("Working"))) ? 'var(--success-color)' : 
                                        (p.status && p.status.startsWith("Error")) ? 'var(--danger-color)' : '#666';
                        
                        const taskStr = p.task || "Unknown Task";
                        const safeDesc = escapeHtml(p.description || "");
                        const safeHost = escapeHtml(p.hostname || "Unknown");
                        const nameDisplay = p.description 
                            ? `<div style="line-height:1.2;">${safeDesc}</div><div style="font-size:0.75rem; color:#666;">${safeHost}</div>` 
                            : safeHost;
                        
                        // ID for in-place edit
                        const nodeId = "node-" + (p.ip || "unknown").replace(/\./g, '-');

                        return `
                    <div class="tree-node" id="${nodeId}">
                        <div class="device-node" style="${isMe ? 'border:1px solid #333;' : ''}">
                            <div data-action="open-node" data-link="${escapeAttr(finalLink)}" style="cursor:pointer; display:flex; align-items:center; flex:1;" title="Task: ${escapeAttr(taskStr)} | Click to open dashboard">
                                <span class="node-name-label" style="color:${isMe ? 'white':'#aaa'}; font-weight:bold;">${nameDisplay}</span>
                            </div>
                            
                            <span class="edit-icon" data-action="rename" data-node-id="${escapeAttr(nodeId)}" data-ip="${escapeAttr(p.ip || "")}" data-desc="${escapeAttr(p.description || "")}" data-hostname="${escapeAttr(p.hostname || "")}" title="Rename Node">‚úèÔ∏è</span>

                            <span style="margin-left:10px; font-size: 0.8rem; color:#888;">${taskStr}</span>
                            <span style="margin-left:5px; font-size: 0.8rem; color:${p.online ? statusColor : '#666'}">[${p.online ? (p.status || 'Active') : 'Offline'}]</span>
                            <div style="flex:0.1"></div>
                            <span style="color:#444; font-size:0.8rem;">${isMe ? "(This Device)" : p.ip}</span>
                        </div>
                    </div>
                `}).join('');
            }
            // Only update if changed to prevent hover flicker
            if (container.innerHTML !== html) {
                container.innerHTML = html;
            }
        }

        async function crawlNetwork(localPeers) {
            isCrawling = true;
            const nodeMap = new Map();
            const links = [];

            // Add Self
            nodeMap.set(myDevice.hostname, myDevice);

            // Add Local Peers (Degree 1) and Links from Me -> Them
            localPeers.forEach(p => {
                nodeMap.set(p.hostname, p);
                links.push({ source: myDevice.hostname, target: p.hostname });
            });

            // Fetch Degree 2 (Peers of Peers)
            // This allows us to see connections between my peers
            const promises = localPeers.map(async (p) => {
                if (!p.ip) return;
                try {
                    const controller = new AbortController();
                    const id = setTimeout(() => controller.abort(), 2000); // 2s Timeout
                    
                    const res = await fetch(`http://${p.ip}/api/peers`, { signal: controller.signal });
                    clearTimeout(id);
                    
                    if (res.ok) {
                        const remotePeers = await res.json();
                        remotePeers.forEach(rp => {
                            // Link p -> rp
                            links.push({ source: p.hostname, target: rp.hostname });

                            // If we haven't seen this node, it's a Degree 2 node
                            if (!nodeMap.has(rp.hostname)) {
                                rp.degree = 2; 
                                nodeMap.set(rp.hostname, rp);
                            }
                        });
                    }
                } catch (e) {
                    // Peer might be offline or CORS blocked (if old firmware)
                    // console.warn("Crawl failed for", p.hostname); 
                }
            });

            await Promise.all(promises);
            
            updateNetworkGraph(Array.from(nodeMap.values()), links);
            isCrawling = false;
        }

        // --- Force Directed Graph Logic ---
        
        function updateNetworkGraph(nodes, externalLinks) {
            // nodes is [ {hostname, cluster, status...}, ... ]
            
            // 1. Map current netNodes to a map for lookup (preserve positions)
            const existing = new Map(netNodes.map(n => [n.id, n]));
            
            // 2. Build new node list
            netNodes = nodes.map(n => {
                const id = n.hostname;
                const old = existing.get(id);
                // Random position start if new
                const x = old ? old.x : (netCanvas.width/2 + (Math.random()-0.5)*50);
                const y = old ? old.y : (netCanvas.height/2 + (Math.random()-0.5)*50);
                
                return {
                    id: id,
                    x: x,
                    y: y,
                    vx: old ? old.vx : 0,
                    vy: old ? old.vy : 0,
                    data: n
                };
            });

            // 3. Build Links
            if (externalLinks) {
                // Use crawled links
                netLinks = externalLinks;
            } else {
                // Fallback: Star Topology
                netLinks = [];
                const centerId = myDevice.hostname;
                netNodes.forEach(n => {
                    if (n.id !== centerId) {
                        netLinks.push({ source: centerId, target: n.id });
                    }
                });
            }
        }

        function runForceSimulation() {
            if(!netNodes.length) {
                requestAnimationFrame(runForceSimulation);
                return;
            }

            const width = netCanvas.width;
            const height = netCanvas.height;
            const k = 100; // ideal distance
            
            // 0. Center Forces (Gravity)
            const cx = width / 2;
            const cy = height / 2;

            // Physics Step
            netNodes.forEach(n => {
                // Repulsion (Coulomb)
                netNodes.forEach(other => {
                    if (n !== other) {
                        const dx = n.x - other.x;
                        const dy = n.y - other.y;
                        const distSq = dx*dx + dy*dy;
                        const dist = Math.sqrt(distSq) || 1;
                        const force = 2000 / distSq; // Repulsion strength
                        n.vx += (dx / dist) * force;
                        n.vy += (dy / dist) * force;
                    }
                });

                // Center Gravity (weak)
                n.vx += (cx - n.x) * 0.005;
                n.vy += (cy - n.y) * 0.005;

                // Cluster Gravity (Group similar clusters)
                // TODO: Find center of mass of cluster? 
                // Simple version: Nodes in same cluster attract slightly
                /*
                netNodes.forEach(other => {
                    if (n !== other && n.data.cluster === other.data.cluster) {
                        const dx = other.x - n.x;
                        const dy = other.y - n.y;
                         n.vx += dx * 0.001;
                         n.vy += dy * 0.001;
                    }
                });
                */
            });

            // Link Attraction (Spring)
            netLinks.forEach(l => {
                // Find node objects
                const s = netNodes.find(n => n.id === l.source);
                const t = netNodes.find(n => n.id === l.target);
                if (s && t) {
                    const dx = t.x - s.x;
                    const dy = t.y - s.y;
                    const dist = Math.sqrt(dx*dx + dy*dy) || 1;
                    const force = (dist - k) * 0.05; // Spring constant
                    
                    const fx = (dx / dist) * force;
                    const fy = (dy / dist) * force;
                    
                    s.vx += fx;
                    s.vy += fy;
                    t.vx -= fx;
                    t.vy -= fy;
                }
            });

            // Integration & Bounds
            netNodes.forEach(n => {
                n.vx *= 0.8; // Friction
                n.vy *= 0.8;
                
                // Max speed clamp
                const speed = Math.sqrt(n.vx*n.vx + n.vy*n.vy);
                if(speed > 10) {
                    n.vx = (n.vx/speed)*10;
                    n.vy = (n.vy/speed)*10;
                }

                n.x += n.vx;
                n.y += n.vy;

                // Wall bounce
                if(n.x < 20) { n.x = 20; n.vx *= -0.5; }
                if(n.x > width-20) { n.x = width-20; n.vx *= -0.5; }
                if(n.y < 20) { n.y = 20; n.vy *= -0.5; }
                if(n.y > height-20) { n.y = height-20; n.vy *= -0.5; }
            });

            // Draw
            netCtx.clearRect(0, 0, width, height);

            // Draw Links
            netCtx.strokeStyle = '#2196F3';
            netCtx.lineWidth = 1;
            netCtx.beginPath();
            netLinks.forEach(l => {
                const s = netNodes.find(n => n.id === l.source);
                const t = netNodes.find(n => n.id === l.target);
                if (s && t) {
                    netCtx.moveTo(s.x, s.y);
                    netCtx.lineTo(t.x, t.y);
                }
            });
            netCtx.stroke();

            // Draw Nodes
            netNodes.forEach(n => {
                netCtx.beginPath();
                netCtx.arc(n.x, n.y, 8, 0, 2 * Math.PI);
                
                // Color by Status/Self
                if (n.data.isSelf) netCtx.fillStyle = '#03dac6'; // Cyan
                else if (n.data.online) netCtx.fillStyle = '#bb86fc'; // Purple
                else netCtx.fillStyle = '#444'; // Gray
                
                netCtx.fill();
                netCtx.strokeStyle = '#000';
                netCtx.lineWidth = 2;
                netCtx.stroke();

                // Labels
                netCtx.fillStyle = '#fff';
                netCtx.font = '10px Consolas';
                const label = n.data.description ? n.data.description : n.id;
                netCtx.fillText(label, n.x + 10, n.y + 3);
            });

            requestAnimationFrame(runForceSimulation);
        }
        
        // Start Sim
        runForceSimulation();

        // Canvas Interaction (Click to Visit)
        netCanvas.addEventListener('click', (e) => {
            const rect = netCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Check collision with nodes
            for (const n of netNodes) {
                const dx = mouseX - n.x;
                const dy = mouseY - n.y;
                // Hit radius 12 (drawn radius is 8)
                if (dx*dx + dy*dy < 144) { 
                    const p = n.data;
                    const link = `http://${(p.hostname || p.ip).toLowerCase()}.local`;
                    const alternateLink = `http://${p.ip}`; 
                    const finalLink = (p.hostname && p.hostname !== "Unknown") ? link : alternateLink;
                    window.location.href = finalLink;
                    break;
                }
            }
        });

        // Mouse Move for Cursor
        netCanvas.addEventListener('mousemove', (e) => {
            const rect = netCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            let hover = false;
            for (const n of netNodes) {
                const dx = mouseX - n.x;
                const dy = mouseY - n.y;
                if (dx*dx + dy*dy < 144) {
                    hover = true;
                    break;
                }
            }
            netCanvas.style.cursor = hover ? 'pointer' : 'default';
        });

        // --- Apply Manual Override ---
        async function startManualScan() {
            const start = document.getElementById('scan-start-freq').value;
            const stop = document.getElementById('scan-stop-freq').value;
            const continuous = document.getElementById('scan-continuous').checked;

            try {
                // Placeholder for real scan task
                alert("Starting Scan\nStart: " + start + "\nStop: " + stop + "\nContinuous: " + continuous);
                /* 
                await fetch('/api/task', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ plugin: "ManualScan", params: { start, stop, continuous } }) 
                });
                */
            } catch(e) {
                alert("Start Failed: " + e);
            }
        }

        async function stopManualScan() {
             try {
                 await fetch('/api/task', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ plugin: "SystemIdle" }) 
                });
                alert("Scan Stopped (Idle)");
            } catch(e) {
                alert("Stop Failed: " + e);
            }
        }

        /* --- NEW: Task System Logic --- */
        let globalTaskCatalog = [];
        let activeTaskId = null;
        let taskTimerInt = null;
        let taskStartTime = 0;

        async function loadTaskCatalog() {
            const container = document.getElementById('task-catalog-container');
            if(!container) return;
            
            try {
                const res = await fetch('/api/task');
                globalTaskCatalog = await res.json();
                
                 container.innerHTML = '';
                 if(!globalTaskCatalog.length) {
                     container.innerHTML = '<div style="padding:10px; color:#666;">No tasks available</div>';
                     return;
                 }
                 
                 // Group by Plugin
                 const tasksByPlugin = {};
                 globalTaskCatalog.forEach(task => {
                     const p = task.plugin || 'General';
                     if(!tasksByPlugin[p]) tasksByPlugin[p] = [];
                     tasksByPlugin[p].push(task);
                 });
                 
                 // Sort and Render
                 Object.keys(tasksByPlugin).sort().forEach(plugin => {
                     // Header
                     const header = document.createElement('div');
                     header.textContent = plugin;
                     header.style.cssText = 'padding: 15px 12px 5px 12px; color: #03dac6; font-size: 0.75rem; font-weight: bold; text-transform: uppercase; letter-spacing: 0.05em; border-bottom: 1px solid #333; background: #1e1e1e; position: sticky; top: 0;';
                     container.appendChild(header);
                     
                     // Tasks
                     tasksByPlugin[plugin].forEach(task => {
                        const btn = document.createElement('div');
                        btn.className = 'task-btn';
                        btn.id = 'task-btn-' + task.id;
                        btn.innerHTML = `<span class="name">${task.name}</span><span class="desc">${task.description}</span>`;
                        btn.onclick = () => selectTask(task.id);
                        container.appendChild(btn);
                     });
                 });

            } catch(e) {
                container.innerHTML = '<div style="color:#cf6679; padding:10px;">Failed to load catalog</div>';
            }
        }
        
        function selectTask(taskId) {
            const task = globalTaskCatalog.find(t => t.id === taskId);
            if (!task) return;
            activeTaskId = taskId;

            // Highlight Selection
            document.querySelectorAll('.task-btn').forEach(b => b.classList.remove('selected'));
            const btn = document.getElementById('task-btn-' + taskId);
            if(btn) btn.classList.add('selected');

            // Show in Col 3
            document.getElementById('work-intro').style.display = 'none';
            document.getElementById('work-running').style.display = 'none';
            document.getElementById('work-form').style.display = 'block';

            // Build Form
            let html = `<div class="form-header"><div class="form-title">${task.name}</div><div class="form-desc">${task.description}</div></div>`;
            
            if (task.inputs && task.inputs.length > 0) {
                task.inputs.forEach(input => {
                    html += `<div class="form-group">`;
                    html += `<label class="form-label">${input.label || input.name}</label>`;
                    if (input.type === 'select' && input.options) {
                        html += `<select class="form-select" name="${input.name}">`;
                        input.options.forEach(opt => {
                            const val = (typeof opt === 'object') ? opt.value : opt;
                            const lbl = (typeof opt === 'object') ? opt.label : opt;
                            html += `<option value="${val}">${lbl}</option>`;
                        });
                        html += `</select>`;
                    } else if (input.type === 'number') {
                         html += `<input class="form-input" type="number" name="${input.name}" 
                                        value="${input.default || ''}" step="${input.step || 'any'}">`;
                    } else if (input.type === 'boolean') {
                         html += `<div style="display:flex; align-items:center;">`;
                         html += `<input type="checkbox" name="${input.name}" ${input.default ? 'checked':''} 
                                        style="margin-right:10px;">`;
                         html += `<label class="form-check-label">${input.label || input.name}</label></div>`;
                    } else {
                        html += `<input class="form-input" type="text" name="${input.name}" value="${input.default || ''}">`;
                    }
                    html += `</div>`;
                });
            } else {
                html += `<div style="padding:20px; color:#888; font-style:italic; text-align:center;">Instant Execution - No parameters required.</div>`;
            }
            
            html += `<button class="cta-button" onclick="submitTask()">LAUNCH TASK</button>`;
            document.getElementById('task-form-container').innerHTML = html;
            
            if(window.innerWidth < 1000) switchMobileCol('work');
        }

        function resetWorkspace() {
            activeTaskId = null;
            document.getElementById('work-form').style.display = 'none';
            document.getElementById('work-running').style.display = 'none';
            document.getElementById('work-intro').style.display = 'flex';
            document.querySelectorAll('.task-btn').forEach(b => b.classList.remove('selected'));
        }
        // Alias
        const resetTaskView = resetWorkspace;

        async function submitTask() {
            if (!activeTaskId) return;

            const form = document.getElementById('task-form-container');
            const payload = { plugin: activeTaskId, params: {} };
            
            form.querySelectorAll('select').forEach(el => payload.params[el.name] = el.value);
            form.querySelectorAll('input').forEach(el => {
                if(el.type === 'checkbox') payload.params[el.name] = el.checked;
                else if(el.type === 'number') payload.params[el.name] = parseFloat(el.value);
                else payload.params[el.name] = el.value;
            });

            // UI Transition
            document.getElementById('work-form').style.display = 'none';
            document.getElementById('work-running').style.display = 'flex';
            document.getElementById('execution-status-text').textContent = "Transmitting Command...";

            try {
                const res = await fetch('/api/task', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(payload)
                });
                if (!res.ok) throw new Error("Launch failed");
                
                document.getElementById('execution-status-text').textContent = "Mission Active";
                startExecutionTimer();
                fetchStatus();
            } catch(e) {
                alert("Error: " + e.message);
                resetWorkspace();
            }
        }
        
        async function abortTask() {
             try {
                 await fetch('/api/task', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ plugin: "SystemIdle" }) 
                });
                resetWorkspace();
            } catch(e) { alert("Abort failed: " + e); }
        }

        function startExecutionTimer() {
            taskStartTime = Date.now();
            if(taskTimerInt) clearInterval(taskTimerInt);
            taskTimerInt = setInterval(() => {
                const diff = Math.floor((Date.now() - taskStartTime) / 1000);
                const h = Math.floor(diff / 3600).toString().padStart(2,'0');
                const m = Math.floor((diff % 3600) / 60).toString().padStart(2,'0');
                const s = (diff % 60).toString().padStart(2,'0');
                const el = document.getElementById('execution-timer');
                if(el) el.innerText = `${h}:${m}:${s}`;
            }, 1000);
        }

        function stopExecutionTimer() {
            if(taskTimerInt) clearInterval(taskTimerInt);
            const el = document.getElementById('execution-timer');
            if(el) el.innerText = "00:00:00";
        }

        // --- Event Binding (CSP Safe) ---
        function bindEvents() {
            function safeBind(id, handler) {
                const el = document.getElementById(id);
                if(el) {
                    el.onclick = handler;
                    el.style.cursor = 'pointer'; // Ensure visual cue
                }
            }

            // Mobile Tabs
            safeBind('mob-btn-env', () => switchMobileCol('env'));
            safeBind('mob-btn-ctrl', () => switchMobileCol('ctrl'));
            safeBind('mob-btn-work', () => switchMobileCol('work'));

            // Sub-tabs
            safeBind('btn-sub-tasks', () => switchControlTab('tasks'));
            safeBind('btn-sub-device', () => switchControlTab('device'));
            safeBind('btn-log-tail', () => switchLogMode('tail'));
            safeBind('btn-log-head', () => switchLogMode('head'));

            // Actions
            safeBind('btn-scan-start', startManualScan);
            safeBind('btn-scan-stop', stopManualScan);
            safeBind('btn-update-identity', applyIdentity);
            safeBind('led-indicator', configureLed);

            // New: Load Catalog on init
            loadTaskCatalog();

            // Cluster Tree Delegation
            const tree = document.getElementById('cluster-tree');
            if(tree) {
                tree.onclick = (e) => {
                    const renameEl = e.target.closest('[data-action="rename"]');
                    if (renameEl) {
                        e.stopPropagation();
                        startRename(
                            renameEl.dataset.nodeId,
                            renameEl.dataset.ip,
                            renameEl.dataset.desc || "",
                            renameEl.dataset.hostname || ""
                        );
                        return;
                    }

                    const openEl = e.target.closest('[data-action="open-node"]');
                    if (openEl && openEl.dataset.link) {
                        window.location.href = openEl.dataset.link;
                    }
                };
            }
        }
        
        // Run Bindings
        bindEvents();

        // --- Inline Renaming Logic ---
        function startRename(nodeId, ip, currentDesc, hostname) {
            const nodeEl = document.getElementById(nodeId);
            if(!nodeEl) return;

            const nameArea = nodeEl.querySelector('.node-name-label');
            if(!nameArea) return;
            
            // Avoid double-edit
            if(nameArea.querySelector('input')) return;

            // Save old content
            const oldHtml = nameArea.innerHTML;

            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentDesc;
            input.placeholder = hostname;
            input.className = 'rename-input';
            
            // Interaction
            input.onkeydown = (e) => {
                if(e.key === 'Enter') {
                     input.disabled = true; 
                     input.classList.remove('rename-input'); // Allow polling to resume
                     saveNodeName(ip, input.value);
                }
                if(e.key === 'Escape') {
                    nameArea.innerHTML = oldHtml;
                }
                e.stopPropagation(); // prevent tree click
            };
            input.onclick = (e) => e.stopPropagation();
            
            nameArea.innerHTML = '';
            nameArea.appendChild(input);
            input.focus();
        }

        async function saveNodeName(ip, newDesc) {
            try {
                // Cross-Origin Request to the target node
                // Requires the target node to support CORS headers (Config.cpp/WebServer.cpp likely handles this globally or limited)
                const targetUrl = `http://${ip}/api/config`; 
                
                const res = await fetch(targetUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ description: newDesc }) 
                });
                
                if(!res.ok) throw new Error("Node rejected update");
                
                // Refresh list
                setTimeout(fetchStatus, 500);
                
            } catch(e) {
                alert("Failed to update remote node: " + e.message + "\n(Ensure nodes are on same version)");
            }
        }

        // Dummy Viz
        function drawPattern() {
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.fillRect(0,0,canvas.width, canvas.height);
            
            ctx.fillStyle = '#03dac6';
            const h = canvas.height;
            const w = canvas.width;
            
            // Draw grid
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for(let x=0; x<w; x+=50) { ctx.moveTo(x,0); ctx.lineTo(x,h); }
            ctx.stroke();

            for(let i=0; i<w; i+=10) {
                const noise = Math.random() * (h * 0.8);
                ctx.fillRect(i, h - noise, 8, noise);
            }
            requestAnimationFrame(drawPattern);
        }
        drawPattern();

        // Init Tab
        switchMobileCol('env');
    </script>
